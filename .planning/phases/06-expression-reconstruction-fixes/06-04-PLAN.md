---
phase: 06-expression-reconstruction-fixes
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - vcdecomp/core/ir/structure/orchestrator.py
  - vcdecomp/core/ir/structure/analysis/variables.py
  - .planning/phases/06-expression-reconstruction-fixes/DEBUG_FINDINGS.md
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Pattern 1 fix effectiveness is diagnosed (why goto block_3 still generated)"
    - "Pattern 5 fix effectiveness is diagnosed (why vec/enum_pl still undeclared)"
    - "Debug logging reveals execution flow through fixes"
    - "Root causes documented for ineffective fixes"
  artifacts:
    - path: "vcdecomp/core/ir/structure/orchestrator.py"
      provides: "Debug logging in orphaned block detection (lines 763-815)"
      contains: "Skipping goto to block.*- orphaned"
    - path: "vcdecomp/core/ir/structure/analysis/variables.py"
      provides: "Debug logging in regex variable extraction (lines 385-419)"
      contains: "Found addr_of variable"
    - path: ".planning/phases/06-expression-reconstruction-fixes/DEBUG_FINDINGS.md"
      provides: "Documented diagnosis of why fixes ineffective"
      min_lines: 50
  key_links:
    - from: "orchestrator.py"
      to: "is_orphaned_target flag"
      via: "conditional goto emission"
      pattern: "if not is_switch_header_jump and not is_orphaned_target"
    - from: "variables.py"
      to: "var_types dictionary"
      via: "regex findall results"
      pattern: "re\\.findall.*&(\\w+)"
---

<objective>
Debug why Pattern 1 and Pattern 5 fixes are ineffective despite correct implementation.

Purpose: The orphaned block detection and regex variable extraction were theoretically sound but 0/3 tests compile. Add debug logging to trace execution flow, identify why block_3 still gets goto statement, and why vec/enum_pl remain undeclared. This diagnosis enables correct fixes in subsequent plan.

Output: DEBUG_FINDINGS.md with root cause analysis and enhanced logging showing execution flow through fixes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-expression-reconstruction-fixes/06-CONTEXT.md

# Gap sources
@.planning/phases/06-expression-reconstruction-fixes/06-VERIFICATION.md
@.planning/phases/06-expression-reconstruction-fixes/PHASE_COMPLETION.md
@.planning/phases/06-expression-reconstruction-fixes/FIX_RESULTS.md
@.planning/phases/06-expression-reconstruction-fixes/ERROR_BASELINE.md

# Existing fix implementations
@.planning/phases/06-expression-reconstruction-fixes/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Add debug logging to Pattern 1 fix (orphaned goto detection)</name>
  <files>vcdecomp/core/ir/structure/orchestrator.py</files>
  <action>
Add comprehensive logging to orphaned block detection code (lines 763-815) to trace why goto block_3 is still generated:

**Location 1: Conditional jump handling (around line 763-786)**

Add logging BEFORE the orphaned check:
```python
import logging
logger = logging.getLogger(__name__)

# Before line 765 (is_orphaned_target check)
logger.warning(f"[GOTO DEBUG] Checking block {target_block} for orphaned status in function {func_block_ids}")
logger.warning(f"[GOTO DEBUG] Target in CFG: {target_block in cfg.blocks}, Target in func: {target_block in func_block_ids}")
if target_block >= 0 and target_block in cfg.blocks:
    target_cfg_block = cfg.blocks[target_block]
    predecessors = [p for p in target_cfg_block.predecessors if p in func_block_ids]
    logger.warning(f"[GOTO DEBUG] Block {target_block} predecessors: {predecessors}")
```

Add logging AFTER orphaned decision:
```python
# After is_orphaned_target is set
if is_orphaned_target:
    logger.warning(f"[GOTO DEBUG] SKIPPING goto to block {target_block} - marked orphaned")
else:
    logger.warning(f"[GOTO DEBUG] EMITTING goto to block {target_block} - not orphaned")
```

**Location 2: Unconditional jump handling (around line 790-815)**

Add identical logging for unconditional jumps.

**Goal**: Log every goto decision for test1/tt.scr func_0050 to see if block_3 check executes and what it decides.

**IMPORTANT**: Only add logging, do NOT change logic. We need to see what current code does.
  </action>
  <verify>
```bash
# Verify logging added
grep -n "\[GOTO DEBUG\]" "C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\structure\orchestrator.py"

# Run test with logging visible
cd "C:\Users\flori\source\repos\VC_Scripter"
PYTHONPATH=. python -m pytest vcdecomp/tests/test_validation.py::test_decompilation_validation[tt-turntable] -v --basetemp=.test_artifacts_debug --log-cli-level=WARNING 2>&1 | tee debug_pattern1.txt

# Check if block_3 logging appears
grep "block.*3" debug_pattern1.txt
```
  </verify>
  <done>
- Debug logging added to orchestrator.py orphaned block detection
- Test run shows goto decision logging for all blocks
- debug_pattern1.txt captures execution trace for Pattern 1
  </done>
</task>

<task type="auto">
  <name>Add debug logging to Pattern 5 fix (variable extraction)</name>
  <files>vcdecomp/core/ir/structure/analysis/variables.py</files>
  <action>
Add comprehensive logging to regex variable extraction (lines 385-419) to trace why vec/enum_pl not declared:

**Location: Regex extraction loop (around line 395-410)**

Add logging to show what regex finds:
```python
import logging
logger = logging.getLogger(__name__)

# After line 395 (re.findall call)
addr_of_vars = re.findall(r'&(\w+)', expr.text)
if addr_of_vars:
    logger.warning(f"[VAR DEBUG] Found addr_of variables: {addr_of_vars} in expression: {expr.text[:80]}")

# Inside the for var_name in addr_of_vars loop
for var_name in addr_of_vars:
    logger.warning(f"[VAR DEBUG] Processing variable '{var_name}'")
    if var_name not in var_types:
        # Type inference logic here
        if var_name in ('vec', 'pos', 'rot', 'dir'):
            var_type = "s_SC_vector"
            logger.warning(f"[VAR DEBUG] Inferred type s_SC_vector for '{var_name}'")
        elif 'enum' in var_name.lower():
            var_type = "s_SC_MP_EnumPlayers"
            logger.warning(f"[VAR DEBUG] Inferred type s_SC_MP_EnumPlayers for '{var_name}'")
        else:
            var_type = "int"
            logger.warning(f"[VAR DEBUG] Defaulted to int for '{var_name}'")
        var_types[var_name] = var_type
    else:
        logger.warning(f"[VAR DEBUG] Variable '{var_name}' already in var_types as {var_types[var_name]}")

# After the loop completes
logger.warning(f"[VAR DEBUG] Final var_types dictionary has {len(var_types)} variables")
```

**Goal**: See if regex finds 'vec' and 'enum_pl', whether they get added to var_types, and if they appear in final output.

**IMPORTANT**: Only add logging, do NOT change extraction logic.
  </action>
  <verify>
```bash
# Verify logging added
grep -n "\[VAR DEBUG\]" "C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\structure\analysis\variables.py"

# Run test3/LEVEL (has vec and enum_pl) with logging
cd "C:\Users\flori\source\repos\VC_Scripter"
PYTHONPATH=. python -m pytest vcdecomp/tests/test_validation.py::test_decompilation_validation[level-script] -v --basetemp=.test_artifacts_debug --log-cli-level=WARNING 2>&1 | tee debug_pattern5.txt

# Check if vec/enum_pl found
grep -E "vec|enum_pl" debug_pattern5.txt
```
  </verify>
  <done>
- Debug logging added to variables.py regex extraction
- Test run shows variable discovery logging
- debug_pattern5.txt captures execution trace for Pattern 5
  </done>
</task>

<task type="auto">
  <name>Analyze debug output and document findings</name>
  <files>.planning/phases/06-expression-reconstruction-fixes/DEBUG_FINDINGS.md</files>
  <action>
Analyze debug_pattern1.txt and debug_pattern5.txt to diagnose why fixes are ineffective.

Create DEBUG_FINDINGS.md with:

## Structure

### Pattern 1 Diagnosis: Undefined goto labels

**Question**: Why does `goto block_3;` still appear in test1_tt_decompiled.c line 35?

**Hypothesis from PHASE_COMPLETION.md**:
1. Block_3 not marked orphaned when goto generated (timing)
2. ScriptMain/func_0612 AttributeError generates invalid code
3. Goto generated through uncovered code path

**Evidence from debug_pattern1.txt**:
1. Search for `[GOTO DEBUG] Checking block 3`:
   - Does it appear? YES/NO
   - If YES: What are predecessors? Is it marked orphaned?
   - If NO: Why doesn't orphaned check run for block_3?

2. Check func_0050 decompilation:
   - Does func_0050 complete successfully or fail?
   - If fails: goto may be from error recovery code path

3. Timeline analysis:
   - When is block_3 checked: before/during/after func_0050 structure analysis?
   - When is goto emitted: same phase or later?

**Root Cause**: [Document actual reason based on evidence]

**Fix Required**: [What code change would address root cause]

---

### Pattern 5 Diagnosis: Undeclared variables

**Question**: Why are `vec` and `enum_pl` still undeclared in test3/LEVEL_decompiled.c?

**Hypothesis from PHASE_COMPLETION.md**:
1. Regex runs but variables filtered out by skip conditions
2. Regex runs too late in pipeline
3. Variables appear in different form during SSA

**Evidence from debug_pattern5.txt**:
1. Search for `[VAR DEBUG] Found addr_of variables`:
   - Does regex find 'vec'? YES/NO
   - Does regex find 'enum_pl'? YES/NO
   - What expressions contain these variables?

2. Check if variables added to var_types:
   - Does logging show "Inferred type s_SC_vector for 'vec'"?
   - Does logging show "Inferred type s_SC_MP_EnumPlayers for 'enum_pl'"?

3. Check final var_types size:
   - How many variables in final var_types?
   - Compare to number of variables in decompiled output

4. Timing analysis:
   - When does regex extraction run?
   - When are variable declarations emitted?
   - Could variables be needed before they're collected?

**Root Cause**: [Document actual reason based on evidence]

**Fix Required**: [What code change would address root cause]

---

### Cross-Pattern Analysis

**Are fixes running at all?**
- Pattern 1 logging appears: YES/NO
- Pattern 5 logging appears: YES/NO

**If NO**: Fix code not executed (maybe wrong code path)
**If YES**: Fix logic has bugs

**Interaction effects**:
- Could AttributeError failures cause invalid goto generation?
- Could variables be needed before collection phase runs?

---

### Recommendations

**For Plan 06-05**:
1. [Specific fix for Pattern 1 based on diagnosis]
2. [Specific fix for Pattern 5 based on diagnosis]
3. [Whether to attempt Pattern 3 instead if 1&5 too complex]

**Priority**:
- If fixes just have bugs: Fix them in 06-05
- If architecture issue: May need deeper refactoring
- If timing issue: May need to run collection earlier

## Analysis Method

Read debug output files:
1. grep for GOTO DEBUG and VAR DEBUG markers
2. Extract relevant log lines for block_3 and vec/enum_pl
3. Trace execution timeline
4. Compare to expected behavior
5. Identify gap between expected and actual
6. Document root cause with evidence
  </action>
  <verify>
```bash
# Verify findings document created
test -f "C:\Users\flori\source\repos\VC_Scripter\.planning\phases\06-expression-reconstruction-fixes\DEBUG_FINDINGS.md"
wc -l "C:\Users\flori\source\repos\VC_Scripter\.planning\phases\06-expression-reconstruction-fixes\DEBUG_FINDINGS.md"
# Should be 50+ lines

# Check contains diagnosis sections
grep -q "Pattern 1 Diagnosis" "C:\Users\flori\source\repos\VC_Scripter\.planning\phases\06-expression-reconstruction-fixes\DEBUG_FINDINGS.md"
grep -q "Pattern 5 Diagnosis" "C:\Users\flori\source\repos\VC_Scripter\.planning\phases\06-expression-reconstruction-fixes\DEBUG_FINDINGS.md"
grep -q "Root Cause" "C:\Users\flori\source\repos\VC_Scripter\.planning\phases\06-expression-reconstruction-fixes\DEBUG_FINDINGS.md"

# FIX (06-04): Verify root causes are not placeholders
grep "Root Cause" "C:\Users\flori\source\repos\VC_Scripter\.planning\phases\06-expression-reconstruction-fixes\DEBUG_FINDINGS.md" | grep -v "TBD\|Unknown\|\[Document" || echo "Root causes documented with real content"
```
  </verify>
  <done>
- DEBUG_FINDINGS.md created with diagnosis for both patterns
- Root causes documented with evidence from debug logs (not placeholders)
- Specific fix recommendations provided for Plan 06-05
  </done>
</task>

<task type="auto">
  <name>Commit debug findings</name>
  <files>None (git operations)</files>
  <action>
Commit debug-enhanced code and findings:

```bash
cd "C:\Users\flori\source\repos\VC_Scripter"

git add vcdecomp/core/ir/structure/orchestrator.py
git add vcdecomp/core/ir/structure/analysis/variables.py
git add .planning/phases/06-expression-reconstruction-fixes/DEBUG_FINDINGS.md

git commit -m "$(cat <<'EOF'
debug(06-04): diagnose ineffective Pattern 1 & 5 fixes

Added debug logging to:
- orchestrator.py: Trace orphaned block detection for goto statements
- variables.py: Trace regex variable extraction from expressions

Debug findings:
- Pattern 1: [Root cause for goto block_3 still generated]
- Pattern 5: [Root cause for vec/enum_pl still undeclared]

Gap closure plan 06-04: Diagnose why fixes ineffective.

Next: Plan 06-05 will implement corrected fixes based on diagnosis.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
EOF
)"
```

Update commit message with actual root causes from DEBUG_FINDINGS.md.
  </action>
  <verify>
```bash
# Verify commit created
git log -1 --oneline | grep "debug(06-04)"

# Verify files in commit
git show --name-only HEAD | grep -E "orchestrator|variables|DEBUG_FINDINGS"
```
  </verify>
  <done>
- Debug logging and findings committed
- Commit message documents diagnosed root causes
- Ready for Plan 06-05 (corrected fixes)
  </done>
</task>

</tasks>

<verification>
## Overall Phase Checks

After plan completion:
1. Debug logging added to both Pattern 1 and Pattern 5 fixes
2. Test runs produce detailed execution traces
3. DEBUG_FINDINGS.md documents root causes with evidence
4. Specific fix recommendations ready for next plan

## Success Indicators

- Debug logs show execution flow through fixes
- Root causes identified with concrete evidence (not speculation)
- Diagnosis explains why 0/3 tests compile despite fixes
- Clear path forward for Plan 06-05
</verification>

<success_criteria>
## Measurable Completion

- [ ] Debug logging added to orchestrator.py (Pattern 1)
- [ ] Debug logging added to variables.py (Pattern 5)
- [ ] Test runs complete with debug output captured
- [ ] DEBUG_FINDINGS.md created with root cause analysis (non-placeholder content)
- [ ] Specific fix recommendations documented
- [ ] Debug code and findings committed

## Quality Gates

- Root causes supported by debug log evidence (not guesses)
- Diagnosis explains gap between expected and actual behavior
- Recommendations are actionable code changes for Plan 06-05
- Debug logging does not change program logic (observation only)
</success_criteria>

<output>
After completion, create `.planning/phases/06-expression-reconstruction-fixes/06-04-SUMMARY.md`
</output>
