# Phase 01 Plan 02: Settings Integration and End-to-End Testing

---
phase: 01-gui-validation-integration
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - vcdecomp/gui/main_window.py
autonomous: false

must_haves:
  truths:
    - Compiler directory persists between GUI sessions
    - User can configure validation settings from main menu
    - Settings dialog accessible before first validation attempt
    - Validation works end-to-end for all 3 test scripts
    - Compilation errors display clearly in GUI
  artifacts:
    - path: vcdecomp/gui/main_window.py
      provides: Settings menu integration
      min_lines: 450
      contains: "ValidationSettingsDialog"
    - path: vcdecomp/gui/dialogs/validation_settings.py
      provides: ValidationSettingsDialog with QSettings persistence
      exists: true
  key_links:
    - from: vcdecomp/gui/main_window.py
      to: ValidationSettingsDialog
      via: Settings menu action
      pattern: "ValidationSettingsDialog"
    - from: ValidationPanel.start_validation
      to: QSettings
      via: Load settings when validation runs
      pattern: "QSettings.*VCDecompiler.*ValidationSettings"
---

## Objective

Integrate validation settings into main menu using consistent QSettings namespace. Verify end-to-end validation flow works correctly for test scripts.

**Purpose:** Complete VALID-01, VALID-02, VALID-03 requirements by ensuring settings are accessible and validation results display correctly.

**Output:** Fully functional validation system with persistent settings and verified end-to-end behavior.

## Execution Context

@C:\Users\flori\source\repos\VC_Scripter\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\flori\source\repos\VC_Scripter\.claude\get-shit-done\templates\summary.md

## Context

@C:\Users\flori\source\repos\VC_Scripter\.planning\PROJECT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\ROADMAP.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\STATE.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\01-gui-validation-integration\01-RESEARCH.md

### Prior Work

@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\01-gui-validation-integration\01-01-SUMMARY.md

### Existing Code Context

@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\gui\main_window.py
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\gui\dialogs\validation_settings.py
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\gui\views\validation_view.py

## Tasks

<task type="auto">
  <name>Add Settings menu action to open ValidationSettingsDialog</name>
  <files>vcdecomp/gui/main_window.py</files>
  <action>
Add Settings menu integration to MainWindow:

1. Import ValidationSettingsDialog at top of file:
   ```python
   from .dialogs import ValidationSettingsDialog
   ```

2. In create_menus() method, add Settings action to Tools menu (after validate_action):
   - Create settings_action = QAction("&Settings...", self)
   - Set shortcut to "Ctrl+," (standard settings shortcut)
   - Connect to self.show_validation_settings method
   - Add separator before settings: tools_menu.addSeparator()
   - Add to tools_menu: tools_menu.addAction(settings_action)

3. Implement show_validation_settings() method:
   ```python
   def show_validation_settings(self):
       """Show validation settings dialog"""
       dialog = ValidationSettingsDialog(self)

       # Dialog loads its own settings internally via QSettings
       # (see validation_settings.py line 45: self.settings = QSettings("VCDecompiler", "ValidationSettings"))
       # Dialog also saves automatically when user clicks OK (line 473: save_settings())

       # Just show the dialog - no need to manually load/save
       if dialog.exec() == QDialog.DialogCode.Accepted:
           self.statusBar().showMessage("Validation settings saved", 3000)
   ```

4. Import QDialog at top:
   ```python
   from PyQt6.QtWidgets import (..., QDialog)
   ```

Why this approach:
- ValidationSettingsDialog already handles QSettings persistence internally (lines 45, 476-500, 501-546)
- ValidationPanel reads from QSettings when start_validation() runs (validation_view.py lines 443-453)
- No need for setter methods (they don't exist) - dialog manages its own state
- No need to apply settings to ValidationPanel properties - ValidationPanel reads QSettings directly
- Consistent namespace: Both dialog and panel use "VCDecompiler/ValidationSettings" (not "VC-Scripter/Decompiler")
  </action>
  <verify>
1. Run GUI: `python -m vcdecomp gui`
2. Check Tools menu has "Settings..." option with Ctrl+, shortcut
3. Click Tools > Settings - ValidationSettingsDialog should open
4. Set compiler directory to `C:\Users\flori\source\repos\VC_Scripter\original-resources\compiler`
5. Click OK - status bar should show "Validation settings saved"
6. Close GUI and reopen - settings should persist
7. Open Tools > Settings again - compiler directory should still be set
  </verify>
  <done>
- Tools menu has Settings action with Ctrl+, shortcut
- ValidationSettingsDialog opens when Settings clicked
- Settings persist between GUI sessions using QSettings
- Status bar confirms settings save
- ValidationPanel reads settings from QSettings when validation runs
  </done>
</task>

<task type="auto">
  <name>Add first-run settings prompt to validate_current_script</name>
  <files>vcdecomp/gui/main_window.py</files>
  <action>
Enhance validate_current_script() to prompt for settings if compiler directory not configured:

1. In validate_current_script() method, after checking self.scr is not None, add settings check:
   ```python
   # Check if compiler directory is configured
   # Read from same QSettings namespace that ValidationPanel uses
   settings = QSettings("VCDecompiler", "ValidationSettings")
   compiler_dir = settings.value("compiler_dir", "")

   if not compiler_dir or not Path(compiler_dir).exists():
       result = QMessageBox.question(
           self,
           "Configure Compiler",
           "Compiler directory not configured. Would you like to configure validation settings now?",
           QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
           QMessageBox.StandardButton.Yes
       )

       if result == QMessageBox.StandardButton.Yes:
           self.show_validation_settings()

           # Check again after settings dialog
           settings = QSettings("VCDecompiler", "ValidationSettings")
           compiler_dir = settings.value("compiler_dir", "")
           if not compiler_dir or not Path(compiler_dir).exists():
               QMessageBox.warning(self, "Validation Cancelled", "Cannot validate without valid compiler directory.")
               return
       else:
           return
   ```

2. Import QSettings at top:
   ```python
   from PyQt6.QtCore import Qt, QRegularExpression, QSettings
   ```

3. Import Path from pathlib (already imported for temp file creation in Plan 01)

Why this approach:
- Reads from "VCDecompiler/ValidationSettings" namespace (consistent with dialog and panel)
- Does NOT set instance properties on ValidationPanel (panel reads QSettings directly)
- Prevents cryptic validation errors when compiler not configured
- Question dialog (Yes/No) is more user-friendly than warning
- Re-checking after settings dialog ensures user actually configured it
- Returning early prevents validation attempt with invalid config
- Matches pattern from existing ValidationPanel.on_validate_clicked (lines 400-414 in validation_view.py)
  </action>
  <verify>
1. Run GUI: `python -m vcdecomp gui` (fresh start, clear settings if needed)
2. Load script: Open Compiler-testruns/Testrun1/tdm.scr
3. Click Validate - should show "Configure Compiler" question dialog
4. Click No - validation should cancel
5. Click Validate again, click Yes - settings dialog should open
6. Configure compiler directory and click OK
7. Validation should proceed automatically
  </verify>
  <done>
- validate_current_script() checks for configured compiler directory via QSettings
- Question dialog prompts user to configure settings on first validation
- Clicking No cancels validation
- Clicking Yes opens settings dialog
- Validation proceeds after settings are configured
- Warning shown if user closes settings without configuring
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete end-to-end validation integration with:
- Settings menu action (Ctrl+,) that opens ValidationSettingsDialog
- ValidationSettingsDialog handles its own QSettings persistence automatically
- Consistent QSettings namespace ("VCDecompiler/ValidationSettings") across all components
- ValidationPanel reads settings from QSettings when validation runs (no manual property assignment)
- First-run settings prompt when compiler not configured
- Full validation workflow from menu/toolbar click to results display
  </what-built>
  <how-to-verify>
**Test settings persistence and validation workflow:**

1. **Fresh start (clear settings if needed):**
   ```bash
   # On Windows, delete registry key (optional - skip if unsure):
   # reg delete "HKCU\Software\VCDecompiler\ValidationSettings" /f

   cd C:\Users\flori\source\repos\VC_Scripter
   python -m vcdecomp gui
   ```

2. **Configure settings:**
   - Click Tools > Settings (or press Ctrl+,)
   - Set Compiler Directory: `C:\Users\flori\source\repos\VC_Scripter\original-resources\compiler`
   - Add Include Directory (click Add): `C:\Users\flori\source\repos\VC_Scripter\original-resources\compiler\inc`
   - Set Timeout: 30 seconds (default)
   - Click OK
   - Expected: Status bar shows "Validation settings saved"

3. **Test persistence:**
   - Close GUI completely
   - Reopen: `python -m vcdecomp gui`
   - Click Tools > Settings
   - Expected: Compiler directory and include directory still configured

4. **Test validation with tdm.scr (known working script):**
   - File > Open: `Compiler-testruns\Testrun1\tdm.scr`
   - Click Validate button (toolbar or Tools menu)
   - Expected:
     * Validation dock appears at bottom
     * Progress bar animates
     * Compilation completes (may succeed or fail - both are valid)
     * If fails: Error panel shows .err file content with line numbers
     * If succeeds: Bytecode comparison results shown with differences highlighted

5. **Test validation with hitable.c (another test case):**
   - File > Open: `Compiler-testruns\Testrun3\hitable.scr`
   - Click Validate
   - Expected: Same validation flow, results may differ

6. **Test first-run prompt (optional - requires clearing settings):**
   - Close GUI
   - Clear settings (delete registry key or manually clear compiler_dir in settings dialog)
   - Reopen GUI
   - Load script and click Validate
   - Expected: "Configure Compiler" question dialog appears
   - Click Yes → Settings dialog opens
   - Configure and validate proceeds

**Check ValidationPanel displays results correctly:**

7. After any validation run, check Validation dock shows:
   - Summary tab: Verdict (SUCCESS/FAIL), compilation status, error count
   - Errors tab (if failed): .err file content with stage/severity/message formatting
   - Differences tab: Bytecode comparison tree showing categories (semantic/non-semantic)
   - Export button enabled to save HTML/JSON report

**Success indicators:**
- Settings persist between sessions
- Validation runs without errors
- Results display clearly in ValidationPanel
- First-run experience guides user to configure settings
  </how-to-verify>
  <resume-signal>
Type "approved" if:
- Settings persist correctly between GUI sessions
- Validation completes for at least one test script (tdm.scr or hitable.scr)
- Results display in ValidationPanel with errors or bytecode comparison
- First-run settings prompt works (if tested)

If issues found, describe:
- Which test script was used
- What step failed (settings persistence, validation run, results display)
- Error messages or unexpected behavior observed
  </resume-signal>
</task>

## Verification

Overall validation checks for Plan 02:

1. **Settings integration:**
   - Tools > Settings menu action with Ctrl+, shortcut
   - ValidationSettingsDialog opens and displays current settings
   - Settings persist using QSettings with consistent namespace
   - ValidationPanel reads settings when validation starts

2. **First-run experience:**
   - validate_current_script() prompts for settings if compiler not configured
   - Question dialog offers to open settings
   - Validation proceeds after configuration

3. **End-to-end validation:**
   - Validation completes for test scripts (tdm.scr, hitable.scr)
   - Compilation errors display in ValidationPanel errors tab
   - Bytecode comparison results display in differences tab
   - Summary shows verdict and error counts

4. **Requirements coverage:**
   - VALID-01: ✓ One-click validation from menu/toolbar
   - VALID-02: ✓ Compilation failures show .err file content
   - VALID-03: ✓ Compilation successes show bytecode comparison

## Success Criteria

**Measurable completion:**

- [ ] Tools > Settings menu action opens ValidationSettingsDialog
- [ ] Settings persist between GUI sessions using QSettings
- [ ] ValidationPanel reads settings from QSettings when validation runs
- [ ] First-run validation prompts for settings configuration
- [ ] Validation completes successfully for tdm.scr test script
- [ ] Compilation errors display in ValidationPanel (if script fails)
- [ ] Bytecode comparison displays in ValidationPanel (if script compiles)
- [ ] Export button enabled to save validation reports

**Requirements satisfied:**
- [x] VALID-01: User can click "Compile" button in GUI to validate currently-open script
- [x] VALID-02: Compilation failures show .err file content in GUI
- [x] VALID-03: Compilation successes show bytecode comparison results in GUI

**Phase 1 completion:**
All 3 Phase 1 requirements (VALID-01, VALID-02, VALID-03) are now satisfied. The GUI provides one-click validation with clear error and success reporting.

## Output

After completion, create `.planning/phases/01-gui-validation-integration/01-02-SUMMARY.md` documenting:
- Settings integration approach (QSettings persistence handled by dialog)
- Consistent namespace usage ("VCDecompiler/ValidationSettings")
- End-to-end validation workflow verification
- Test script results (which scripts compile, which fail)
- Known issues or limitations discovered during testing
- Phase 1 completion confirmation
