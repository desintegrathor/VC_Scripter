---
phase: 07-variable-declaration-fixes
plan: 05
type: execute
wave: 3
depends_on: [07-02]
files_modified:
  - vcdecomp/core/ir/structure/analysis/variables.py
  - vcdecomp/core/headers/database.py
  - vcdecomp/tests/test_validation.py
autonomous: true

must_haves:
  truths:
    - "Struct field access reconstructs member names from headers (obj->field_name not obj->field_0)"
    - "Nested access chains use arrow operators (obj->node->pos->x)"
    - "Pointer vs direct access inferred from addressing mode (-> vs .)"
  artifacts:
    - path: "vcdecomp/core/headers/database.py"
      provides: "Struct field lookup by type and offset"
      exports: ["get_struct_fields", "lookup_field_name"]
    - path: "vcdecomp/core/ir/structure/analysis/variables.py"
      provides: "Field access chain reconstruction"
      contains: "_reconstruct_field_access"
  key_links:
    - from: "variables.py"
      to: "database.py::get_struct_fields"
      via: "Field name lookup by struct type + byte offset"
      pattern: "get_struct_fields\\(struct_type"
    - from: "Field access chain"
      to: "Type inference results"
      via: "Struct type determines field lookup"
      pattern: "inferred_struct_types\\[base_var\\]"
---

<objective>
Reconstruct struct field access with correct member names and nested chains.

Purpose: Struct field accesses currently use generic offsets (field_0, field_4) or incorrect member names. This plan implements header-based field name lookup and nested access chain reconstruction.

Output: Readable struct field access (obj->node->position->x) instead of synthetic names or raw offsets.
</objective>

<execution_context>
@C:\Users\flori\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\flori\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\Users\flori\source\repos\VC_Scripter\.planning\PROJECT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\ROADMAP.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\STATE.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-CONTEXT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-RESEARCH.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-02-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\headers\database.py
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\structure\analysis\variables.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend HeaderDatabase with struct field lookup</name>
  <files>vcdecomp/core/headers/database.py</files>
  <action>
Enhance HeaderDatabase to support struct field name lookup:

1. Add method: get_struct_fields(struct_type: str) → Dict[int, FieldInfo]
   ```python
   @dataclass
   class FieldInfo:
       name: str          # Field name (e.g., "position", "x")
       type: str          # Field type (e.g., "float", "s_SC_vector*")
       offset: int        # Byte offset within struct
       size: int          # Field size in bytes

   def get_struct_fields(self, struct_type: str) -> Dict[int, FieldInfo]:
       """Return field definitions for a struct type.

       Returns: {offset: FieldInfo} mapping
       Example: get_struct_fields("s_SC_vector") →
                {0: FieldInfo("x", "float", 0, 4),
                 4: FieldInfo("y", "float", 4, 4),
                 8: FieldInfo("z", "float", 8, 4)}
       """
   ```

2. Parse struct definitions from headers (sc_def.h, sc_global.h):
   ```c
   // Example from sc_def.h
   typedef struct {
       float x;
       float y;
       float z;
   } s_SC_vector;

   typedef struct {
       c_Node* node;
       s_SC_vector* position;
       int flags;
   } s_SC_object;
   ```

3. Build struct database:
   - Parse typedef struct definitions
   - Calculate field offsets (cumulative size, 4-byte alignment)
   - Handle nested structs (field type is another struct)
   - Cache results in JSON (similar to function signature cache)

4. Add fallback: lookup_field_name(struct_type: str, offset: int) → str
   ```python
   field = self.struct_fields.get(struct_type, {}).get(offset)
   if field:
       return field.name
   else:
       return f"field_{offset}"  # Generic fallback
   ```

5. Load struct definitions on initialization:
   - Parse vcdecomp/compiler/inc/sc_def.h (primary source)
   - Parse vcdecomp/compiler/inc/sc_global.h (additional types)
   - Log: "Loaded {N} struct definitions with {M} total fields"

Why this approach: Header files are ground truth for struct layouts. Byte offset calculation matches compiler alignment rules (4-byte for this engine). JSON cache avoids reparsing on every run.

What to avoid: Don't hardcode struct definitions - parse from headers for maintainability. Don't skip alignment - misaligned offsets will give wrong field names. Don't fail on unknown structs - fallback to field_X gracefully.
  </action>
  <verify>
python -m pytest vcdecomp/tests/test_validation.py::test_decompilation_validation -v --log-cli-level=INFO 2>&1 | grep "Loaded.*struct definitions"

Log shows struct database loaded with count of structs and fields.

Test header lookup:
python -c "from vcdecomp.core.headers.database import HeaderDatabase; db = HeaderDatabase(); print(db.get_struct_fields('s_SC_vector'))"

Should print field definitions for s_SC_vector (x, y, z at offsets 0, 4, 8).
  </verify>
  <done>
HeaderDatabase extended with struct field lookup. Struct definitions loaded from sc_def.h and sc_global.h with byte offset calculation. Fallback to field_X for unknown types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement field access chain reconstruction</name>
  <files>vcdecomp/core/ir/structure/analysis/variables.py</files>
  <action>
Add field access chain reconstruction to variables.py:

1. Create method: _reconstruct_field_access(base_var: str, offset: int, is_pointer: bool, inferred_types: Dict) → str
   ```python
   def _reconstruct_field_access(self, base_var: str, offset: int,
                                 is_pointer: bool, inferred_types: Dict) -> str:
       """Reconstruct obj->field or obj.field from base variable and offset.

       Args:
           base_var: Base variable name (e.g., "obj", "local_5")
           offset: Byte offset being accessed
           is_pointer: True if indirect access (->), False if direct (.)
           inferred_types: Type inference results from Plan 07-02

       Returns: Field access string (e.g., "obj->position")
       """

       # Get struct type for base variable
       struct_type = inferred_types.get(base_var)
       if not struct_type or not struct_type.startswith('s_SC_'):
           return f"{base_var}+{offset}"  # Unknown struct, use offset

       # Lookup field name from header database
       field_name = self.header_db.lookup_field_name(struct_type, offset)

       # Generate access syntax
       accessor = "->" if is_pointer else "."
       return f"{base_var}{accessor}{field_name}"
   ```

2. Detect nested access chains:
   ```python
   # Pattern: obj->node->position->x
   # Bytecode: GCP(obj, 0) → tmp1 (get node*)
   #           GCP(tmp1, 4) → tmp2 (get position*)
   #           GCP(tmp2, 0) → tmp3 (get x float)

   def _build_access_chain(accesses: List[FieldAccess]) -> str:
       """Build nested field access chain from sequence of accesses."""
       chain = [accesses[0].base_var]

       for access in accesses:
           accessor = "->" if access.is_pointer else "."
           chain.append(f"{accessor}{access.field_name}")

       return "".join(chain)
   ```

3. Infer pointer vs direct access:
   ```python
   # From addressing mode:
   # - GCP (Get Copy Pointer) → indirect (->)
   # - LCP (Load Copy Pointer) → indirect (->)
   # - Direct offset from base → direct (.)

   is_pointer = inst.mnemonic in ['GCP', 'LCP', 'GADR']
   ```

4. Integrate with existing variable collection:
   - Existing code (lines 112-163) infers struct types from function calls
   - Extend to use field access patterns for type refinement:
     ```python
     # If accessing .x, .y, .z at 0,4,8 → likely s_SC_vector
     # If accessing .node, .position → likely s_SC_object
     access_pattern = [field.name for field in sorted_accesses]
     if access_pattern == ['x', 'y', 'z']:
         refine_type(base_var, 's_SC_vector')
     ```

5. Add logging:
   ```python
   logger.debug(f"Field access: {base_var} ({struct_type}) + {offset} → {field_name}")
   ```

Why this approach: Field access is a sequence of pointer dereferences in bytecode. Tracking access chains and looking up field names in headers produces readable C code. Pattern-based type refinement improves accuracy.

What to avoid: Don't assume all accesses are pointer accesses - check opcode. Don't build infinite chains - detect cycles. Don't skip unknown struct types - use offset fallback.
  </action>
  <verify>
python -m pytest vcdecomp/tests/test_validation.py::test_decompilation_validation -v --log-cli-level=DEBUG 2>&1 | grep "Field access:"

Log shows field access reconstruction with struct types and field names.

Inspect .test_artifacts_07-05/ for field access improvements:
- obj->node instead of obj->field_0
- obj->position->x instead of nested generic offsets
- Correct -> vs . usage based on addressing mode
  </verify>
  <done>
Field access chain reconstruction implemented. Decompiled output shows semantic field names from headers with nested access chains and correct -> vs . operators.
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate struct field reconstruction with compilation tests</name>
  <files>vcdecomp/tests/test_validation.py</files>
  <action>
Validate struct field access improvements:

1. Run decompilation on test1/test2/test3 with field reconstruction
2. Capture output to .test_artifacts_07-05/
3. Manual inspection for struct improvements:

   Expected fixes:
   - Struct types from Plan 07-02 now have meaningful field access
   - SC_NOD_Get() returns c_Node* → variable->field_name not variable->field_0
   - SC_P_GetInfo(&local_X) fills s_SC_P_getinfo → local_X.field_name access

4. Create comparison document: .test_artifacts_07-05/STRUCT_FIELD_RECONSTRUCTION.md
   ```markdown
   # Struct Field Access Validation

   ## Test1 Struct Access
   | Expression | Before | After | Struct Type |
   |------------|--------|-------|-------------|
   | Node position | tmp->field_4->field_0 | tmp->position->x | c_Node* |
   | Player info | local_5.field_8 | local_5.health | s_SC_P_getinfo |

   ## Field Name Coverage
   - Fields resolved from headers: X/Y (Z%)
   - Generic field_N fallbacks: Y/Y

   ## Compilation Results
   - Struct-related errors: Before X → After Y (Z% reduction)
   ```

5. Attempt compilation:
   - Compare struct-related errors vs Plan 07-02 baseline
   - Check for field name errors (undefined field, wrong offset)
   - Document improvements and remaining issues

6. Cross-reference with ERROR_BASELINE.md Pattern 2:
   - Pattern 2 type mismatches may involve struct field access
   - Verify struct field types match usage (position->x is float, not int)

Why this approach: Struct field access errors are subtle - wrong field names compile but produce wrong behavior. Header-based validation ensures semantic correctness.

What to avoid: Don't expect 100% field name coverage - some structs may be missing from headers. Focus on common engine types (c_Node, s_SC_vector, etc.).
  </action>
  <verify>
cat C:/Users/flori/source/repos/VC_Scripter/.test_artifacts_07-05/STRUCT_FIELD_RECONSTRUCTION.md

Report exists with before/after field access comparisons, coverage metrics, and compilation results.
  </verify>
  <done>
Struct field reconstruction validated. Report shows field name improvements, coverage metrics, and struct-related error reduction vs baseline.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:

1. HeaderDatabase loads struct definitions from sc_def.h and sc_global.h
2. Field access chains reconstructed with semantic names (obj->node->pos->x)
3. Pointer vs direct access inferred from opcodes (-> vs .)
4. Unknown struct types fall back gracefully to field_X
5. Compilation shows improvement in struct-related errors
</verification>

<success_criteria>
Measurable completion:

1. Struct database loaded with field definitions (log confirms count)
2. Field access uses header-based names (not all field_0, field_4)
3. Nested access chains appear in decompiled output (obj->a->b format)
4. STRUCT_FIELD_RECONSTRUCTION.md shows systematic before/after comparison
5. Compilation attempt produces fewer struct-related errors than Plan 07-02 baseline
</success_criteria>

<output>
After completion, create `.planning/phases/07-variable-declaration-fixes/07-05-SUMMARY.md`
</output>
