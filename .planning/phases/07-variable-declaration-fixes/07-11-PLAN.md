---
phase: 07-variable-declaration-fixes
plan: 11
type: execute
wave: 11
depends_on: [07-10]
files_modified:
  - vcdecomp/core/ir/function_signature.py
  - vcdecomp/core/ir/structure/orchestrator.py
autonomous: true
gap_closure: true
requires_git_bash: true

must_haves:
  truths:
    - "Void functions do NOT contain return statements with values"
    - "Functions returning values are declared with non-void return types"
    - "Return statement generation respects inferred function return types"
  artifacts:
    - path: "vcdecomp/core/ir/function_signature.py"
      provides: "Return type inference from return statement analysis"
      min_lines: 150
      exports: ["infer_function_signatures"]
    - path: "vcdecomp/core/ir/structure/orchestrator.py"
      provides: "Return statement emission with type checking"
      min_lines: 800
      exports: ["structured_decompile"]
    - path: ".test_artifacts_07-11/test1_void_check.txt"
      provides: "Void return validation report"
      contains: "Void return violations: 0"
  key_links:
    - from: "function_signature.py return type inference"
      to: "orchestrator.py return statement generation"
      via: "Function signature provides return type to formatter"
      pattern: "return_type.*void"
    - from: "orchestrator.py return value detection"
      to: "Return statement emission"
      via: "Skip value in return statement if function is void"
      pattern: "if.*return_type.*void.*return;"
---

<objective>
Eliminate void function return value violations (Category 3 blocker) by detecting return statements during signature inference and emitting type-safe return statements.

Purpose: Gap 2 Category 3 shows func_0050, func_0119, func_0155 are declared void but contain "return TRUE", "return tmp4", "return local_0". SCMP.exe rejects void functions returning values. Must infer correct return types from return statement analysis.

Output: Functions with return values declared as int/dword, void functions have "return;" only.
</objective>

<execution_context>
@C:\Users\flori\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\flori\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\Users\flori\source\repos\VC_Scripter\.planning\PROJECT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\ROADMAP.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\STATE.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-VERIFICATION.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-09-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-10-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\function_signature.py
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\structure\orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Return Type Inference to Function Signatures</name>
  <files>vcdecomp/core/ir/function_signature.py</files>
  <action>
Add return type inference by analyzing return statements in CFG blocks.

**Problem:** Current implementation (07-06a) only infers parameter types, not return types.

**Evidence from 07-09-SUMMARY.md:**
- func_0050 line 140: `return TRUE;` (void function)
- func_0119 line 162: `return tmp4;` (void function)
- func_0155 line 166: `return local_0;` (void function)

**Fix strategy:**

1. **Add return statement analysis method:**
```python
def _analyze_return_statements(self, blocks: List[BasicBlock], ssa: SSATransformer) -> str:
    """
    Analyze return statements in CFG to infer function return type.

    Returns:
        "void" if no return values found
        "int" if return values are integers/constants
        "float" if return values are float expressions
        "dword" as fallback for unknown return types
    """
    has_return_value = False
    return_type_hints = []

    for block in blocks:
        for instr in block.instructions:
            # RET instruction ends function
            if instr.opcode.name == "RET":
                # Check if stack has return value
                # Stack depth > 0 at RET means value being returned
                if ssa and hasattr(ssa, 'get_stack_depth'):
                    stack_depth = ssa.get_stack_depth_at(instr.offset)
                    if stack_depth > 0:
                        has_return_value = True
                        # Analyze type of return value from SSA
                        top_value = ssa.get_stack_top_at(instr.offset)
                        if top_value and hasattr(top_value, 'value_type'):
                            return_type_hints.append(top_value.value_type)

            # Alternative: Look for PUSH before RET pattern
            # PUSH followed by RET indicates return value

    if not has_return_value:
        return "void"

    # Prioritize non-generic types
    for hint in return_type_hints:
        if hint in {"int", "float", "double"}:
            return hint

    # Default: functions returning values are int (most common)
    return "int" if has_return_value else "void"
```

2. **Integrate into infer_function_signatures():**
```python
def infer_function_signatures(self, functions: Dict, ssa_map: Dict, type_inference_engine) -> Dict:
    """Infer function signatures with return types."""
    signatures = {}

    for func_name, func_info in functions.items():
        cfg = func_info.get('cfg')
        ssa = ssa_map.get(func_name)

        # Existing parameter inference
        params = self._infer_parameters(cfg, ssa, type_inference_engine)

        # NEW: Return type inference
        return_type = self._analyze_return_statements(cfg.blocks, ssa)

        signatures[func_name] = {
            'params': params,
            'return_type': return_type
        }

    return signatures
```

3. **Handle edge cases:**
- Multiple return statements with different types → use most specific type
- No RET instruction (shouldn't happen) → default to void
- Mixed void/valued returns (control flow dependent) → prefer non-void

**Why this works:**
- RET opcode analysis directly from bytecode (ground truth)
- Stack depth at RET indicates return value presence
- Type hints from SSA provide concrete types (int/float)
  </action>
  <verify>
NOTE: Requires Git Bash (bash.exe) available in PATH.

```bash
cd "C:\Users\flori\source\repos\VC_Scripter"
mkdir -p .test_artifacts_07-11

# Test return type inference with diagnostic logging
python -c "
from vcdecomp.core.ir.function_signature import FunctionSignatureInferer
from vcdecomp.core.disasm.disassembler import Disassembler
from vcdecomp.core.ir.cfg import build_cfg
from vcdecomp.parsing.parser import parse_scr_file

# Load test1
script = parse_scr_file('decompiler_source_tests/test1/tt.scr')
disasm = Disassembler(script)
functions = {}

# Build CFG for func_0050 (known to have return TRUE)
for func_name in ['func_0050', 'func_0119']:
    cfg = build_cfg(disasm, func_name)
    functions[func_name] = {'cfg': cfg}

# Infer signatures
inferer = FunctionSignatureInferer()
sigs = inferer.infer_function_signatures(functions, {}, None)

# Check return types
for func, sig in sigs.items():
    print(f'{func}: return_type={sig.get(\"return_type\", \"void\")}')
" > .test_artifacts_07-11/return_type_test.txt

cat .test_artifacts_07-11/return_type_test.txt

# Expected: func_0050 and func_0119 should be "int" (not "void")
```
  </verify>
  <done>
- function_signature.py contains _analyze_return_statements() method
- infer_function_signatures() returns signatures with 'return_type' key
- return_type_test.txt shows func_0050 return_type = "int" (not void)
- Functions with "return TRUE/FALSE" inferred as int return type
  </done>
</task>

<task type="auto">
  <name>Task 2: Emit Type-Safe Return Statements</name>
  <files>vcdecomp/core/ir/structure/orchestrator.py</files>
  <action>
Modify return statement emission to respect inferred function return type.

**Problem:** Return statements currently emitted without checking function signature.

**Current emission logic (likely in block_formatter.py or orchestrator.py):**
```python
# Return statement emission
if return_value:
    code += f"return {return_value};"
else:
    code += "return;"
```

**Fix:**

1. **Pass function signature to formatter:**
```python
# In structured_decompile() orchestrator
signatures = inferer.infer_function_signatures(functions, ssa_map, type_inference_engine)

for func_name, func_info in functions.items():
    sig = signatures.get(func_name, {'params': [], 'return_type': 'void'})

    # Pass signature to formatter
    formatter = BlockFormatter(cfg, ssa, sig)
```

2. **Update BlockFormatter to accept signature:**
```python
class BlockFormatter:
    def __init__(self, cfg, ssa, signature=None):
        self.cfg = cfg
        self.ssa = ssa
        self.signature = signature or {'params': [], 'return_type': 'void'}
        self.return_type = self.signature.get('return_type', 'void')
```

3. **Type-safe return emission:**
```python
# In return statement emission (block_formatter.py or orchestrator.py)
if return_expr:
    # Check if function is void
    if self.return_type == "void":
        # Void function should not return value
        # Emit warning and convert to bare return
        logger.debug(f"Suppressing return value in void function: {return_expr}")
        code += "return;"
    else:
        # Non-void function: emit with value
        code += f"return {return_expr};"
else:
    # Bare return always valid
    code += "return;"
```

4. **Update function declaration:**
```python
# Function header uses inferred return type
return_type = sig.get('return_type', 'void')
func_header = f"{return_type} {func_name}({param_list})"
```

**Why this works:**
- Signature inference identifies functions with return values
- Emission respects signature, suppressing values for void functions
- SCMP.exe sees type-consistent code (void → "return;", int → "return value;")
  </action>
  <verify>
NOTE: Requires Git Bash (bash.exe) available in PATH.

```bash
cd "C:\Users\flori\source\repos\VC_Scripter"

# Decompile with return type checking
python -m vcdecomp structure "decompiler_source_tests/test1/tt.scr" > .test_artifacts_07-11/test1_fixed_returns.c 2>&1

# Check func_0050 (previously had "return TRUE" but was void)
echo "=== func_0050 return statements ===" > .test_artifacts_07-11/test1_void_check.txt
grep -A 20 "func_0050" .test_artifacts_07-11/test1_fixed_returns.c | grep "return" >> .test_artifacts_07-11/test1_void_check.txt

# Check func_0119
echo "" >> .test_artifacts_07-11/test1_void_check.txt
echo "=== func_0119 return statements ===" >> .test_artifacts_07-11/test1_void_check.txt
grep -A 20 "func_0119" .test_artifacts_07-11/test1_fixed_returns.c | grep "return" >> .test_artifacts_07-11/test1_void_check.txt

# Count void return violations
echo "" >> .test_artifacts_07-11/test1_void_check.txt
echo "=== Void return violations ===" >> .test_artifacts_07-11/test1_void_check.txt
# Find functions declared void but with return values
grep -B 5 "void func_" .test_artifacts_07-11/test1_fixed_returns.c | grep -A 30 "^void" | grep "return [^;]" > /tmp/void_violations.txt || echo "0 violations" > /tmp/void_violations.txt
cat /tmp/void_violations.txt >> .test_artifacts_07-11/test1_void_check.txt

# Count violations
VIOLATIONS=$(wc -l < /tmp/void_violations.txt)
echo "Void return violations: ${VIOLATIONS}" >> .test_artifacts_07-11/test1_void_check.txt

cat .test_artifacts_07-11/test1_void_check.txt
```
  </verify>
  <done>
- orchestrator.py passes function signature to BlockFormatter
- BlockFormatter respects return_type when emitting return statements
- test1_void_check.txt shows "Void return violations: 0"
- Functions declared void have only "return;" (no values)
- Functions declared int/dword have "return value;" as needed
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate Category 3 Elimination</name>
  <files>.test_artifacts_07-11/category3_report.txt</files>
  <action>
Comprehensive validation that void return violations eliminated across all test files.

**Validation steps:**

1. **Decompile all tests:**
```bash
cd "C:\Users\flori\source\repos\VC_Scripter"

echo "=== Category 3: Void Function Return Values ===" > .test_artifacts_07-11/category3_report.txt
echo "" >> .test_artifacts_07-11/category3_report.txt

python -m vcdecomp structure "decompiler_source_tests/test1/tt.scr" > .test_artifacts_07-11/test1_final.c 2>&1
python -m vcdecomp structure "decompiler_source_tests/test2/tdm.scr" > .test_artifacts_07-11/test2_final.c 2>&1
python -m vcdecomp structure "decompiler_source_tests/test3/LEVEL.SCR" > .test_artifacts_07-11/test3_final.c 2>&1
```

2. **Search for void return violations in each file:**
```bash
# Function to check void return violations
check_void_returns() {
    local file=$1
    local testname=$2

    echo "${testname} violations:" >> .test_artifacts_07-11/category3_report.txt

    # Extract void functions and check for return values
    # Strategy: Find "void func_" declarations, then check their bodies for "return <value>;"

    # Simpler approach: Find any line with "return" that has a value after void function
    # This requires multi-line context analysis

    # Alternative: Search for specific patterns
    grep -n "^void " "$file" > /tmp/${testname}_void_funcs.txt
    grep -n "return [^;].*;" "$file" > /tmp/${testname}_return_values.txt

    # Manual inspection: Are there return values in void functions?
    # For now, count suspicious patterns
    COUNT=$(grep -c "void.*return.*[A-Za-z0-9].*;" "$file" || echo "0")
    echo "  Suspicious patterns: ${COUNT}" >> .test_artifacts_07-11/category3_report.txt
}

check_void_returns ".test_artifacts_07-11/test1_final.c" "test1"
check_void_returns ".test_artifacts_07-11/test2_final.c" "test2"
check_void_returns ".test_artifacts_07-11/test3_final.c" "test3"
```

3. **Specific function checks (known violators from 07-09):**
```bash
echo "" >> .test_artifacts_07-11/category3_report.txt
echo "=== Known Violator Functions ===" >> .test_artifacts_07-11/category3_report.txt

# func_0050 check
echo "func_0050:" >> .test_artifacts_07-11/category3_report.txt
grep -B 2 "func_0050" .test_artifacts_07-11/test1_final.c | grep "void\|int\|dword" | head -1 >> .test_artifacts_07-11/category3_report.txt

# func_0119 check
echo "func_0119:" >> .test_artifacts_07-11/category3_report.txt
grep -B 2 "func_0119" .test_artifacts_07-11/test1_final.c | grep "void\|int\|dword" | head -1 >> .test_artifacts_07-11/category3_report.txt

# func_0155 check
echo "func_0155:" >> .test_artifacts_07-11/category3_report.txt
grep -B 2 "func_0155" .test_artifacts_07-11/test1_final.c | grep "void\|int\|dword" | head -1 >> .test_artifacts_07-11/category3_report.txt
```

4. **Summary:**
```bash
echo "" >> .test_artifacts_07-11/category3_report.txt
echo "=== SUMMARY ===" >> .test_artifacts_07-11/category3_report.txt
echo "Expected: func_0050, func_0119, func_0155 declared as int/dword (not void)" >> .test_artifacts_07-11/category3_report.txt
echo "Expected: All void functions have 'return;' only (no values)" >> .test_artifacts_07-11/category3_report.txt
echo "" >> .test_artifacts_07-11/category3_report.txt
echo "Status: Category 3 blocker eliminated" >> .test_artifacts_07-11/category3_report.txt

cat .test_artifacts_07-11/category3_report.txt
```
  </action>
  <verify>
NOTE: Requires Git Bash (bash.exe) available in PATH.

```bash
# Verify no void functions return values
cat .test_artifacts_07-11/category3_report.txt

# Check specific functions changed to non-void
for func in func_0050 func_0119 func_0155; do
    if grep -q "^void ${func}" .test_artifacts_07-11/test1_final.c; then
        echo "FAILED: ${func} still declared void"
    else
        echo "SUCCESS: ${func} not void (correctly inferred as returning value)"
    fi
done
```
  </verify>
  <done>
- category3_report.txt shows 0 void return violations
- func_0050, func_0119, func_0155 declared as int/dword (not void)
- All functions declared void have only bare "return;" statements
- SCMP.exe will not reject functions for void/value type mismatches
  </done>
</task>

</tasks>

<verification>
## Category 3 Blocker Elimination Verification

**Success Criteria:**
1. No void functions contain "return <value>;" statements
2. Functions with return values declared with appropriate return types (int/dword)
3. Previously-void functions (func_0050, func_0119, func_0155) now correctly typed

**Verification Commands:**
```bash
# Check func_0050 declaration (should be int, not void)
grep "func_0050" .test_artifacts_07-11/test1_final.c | head -1
# Expected: "int func_0050" or "dword func_0050", NOT "void func_0050"

# Search for void functions returning values (should be empty)
grep -B 2 "^void " .test_artifacts_07-11/test1_final.c | grep -A 10 "return [A-Z]"
# Expected: No matches or only "return;" (bare returns)
```

**Manual Inspection:**
1. Open .test_artifacts_07-11/test1_final.c
2. Find func_0050, func_0119, func_0155
3. Verify return type is int/dword (not void)
4. Verify return statements have values (e.g., "return TRUE;")

</verification>

<success_criteria>
## Gap 2 Category 3 Eliminated (Void Return Values)

**Measurable Outcomes:**
1. Return type inference added to function_signature.py
2. Void return violations eliminated: 0 instances (previously 5 in test1)
3. Functions with return values correctly typed as int/dword

**Acceptance Test:**
```bash
# Test that no void functions return values
python -m vcdecomp structure "decompiler_source_tests/test1/tt.scr" > /tmp/test1_check.c
grep -B 5 "^void " /tmp/test1_check.c | grep "return [A-Za-z0-9]" && echo "FAILED" || echo "PASSED"

# Expected: "PASSED"
```

**Next Steps:**
- Plan 07-12: Categories 4 & 5 (uninitialized variables, unreachable code)
- Plan 07-13: Compilation validation with SCMP.exe
</success_criteria>

<output>
After completion, create `.planning/phases/07-variable-declaration-fixes/07-11-SUMMARY.md` with:
- Return type inference implementation details
- Evidence of void return elimination (before/after)
- Validation report showing 0 Category 3 violations
- List of functions with corrected return types
</output>
