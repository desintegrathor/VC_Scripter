---
phase: 07-variable-declaration-fixes
plan: 04
type: execute
wave: 3
depends_on: [07-02]
files_modified:
  - vcdecomp/core/ir/structure/analysis/variables.py
  - vcdecomp/core/ir/value_trace.py
  - vcdecomp/tests/test_validation.py
autonomous: true

must_haves:
  truths:
    - "Arrays are declared with correct dimensions detected from usage patterns"
    - "Multi-dimensional arrays reconstruct as arr[x][y] from nested indexing"
    - "Array bounds calculated from loop analysis and memory layout"
  artifacts:
    - path: "vcdecomp/core/ir/structure/analysis/variables.py"
      provides: "Array dimension detection and declaration generation"
      contains: "_detect_array_dimensions"
    - path: "vcdecomp/core/ir/value_trace.py"
      provides: "Loop bound analysis for array size inference"
      contains: "trace_loop_bounds"
  key_links:
    - from: "variables.py"
      to: "value_trace.py"
      via: "Loop bound queries for dimension inference"
      pattern: "trace_loop_bounds\\("
    - from: "variables.py"
      to: "SSA memory operations"
      via: "Index pattern detection (arr[i*width + j] → arr[i][j])"
      pattern: "MUL.*ADD.*pattern"
---

<objective>
Fix array reconstruction to generate correct dimensions and types.

Purpose: Arrays currently declared with generic sizes or as scalar variables. This plan implements dimension detection from memory layout analysis and loop bounds, supporting both 1D and multi-dimensional arrays.

Output: Array declarations with accurate dimensions (int arr[10], float matrix[3][4]) derived from bytecode usage patterns.
</objective>

<execution_context>
@C:\Users\flori\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\flori\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\Users\flori\source\repos\VC_Scripter\.planning\PROJECT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\ROADMAP.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\STATE.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-CONTEXT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-RESEARCH.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-02-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\structure\analysis\variables.py
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\structure\analysis\value_trace.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement loop bound analysis for array dimension inference</name>
  <files>vcdecomp/core/ir/value_trace.py</files>
  <action>
Add loop bound analysis to value_trace.py (or create analysis/loop_bounds.py if value_trace doesn't exist):

1. Create method: trace_loop_bounds(ssa_func: SSAFunction) → Dict[var_name, BoundInfo]
   ```python
   @dataclass
   class BoundInfo:
       min_value: int  # Minimum index seen
       max_value: int  # Maximum index seen
       step: int       # Iteration step (usually 1)
       confidence: float  # How certain we are about bounds
   ```

2. Detect loop patterns:
   - For loop: `for (i = 0; i < N; i++)` → bounds [0, N)
   - While loop with counter: track counter variable increments
   - Explicit bounds from comparison operations (ICL, ICLE)

3. Extract bounds from:
   - Loop condition comparisons: `i < 10` → max_bound = 10
   - Array access patterns: `arr[i]` where i bounded by loop
   - Constant offsets: `arr[i + 5]` → effective_max = loop_max + 5

4. Handle nested loops for multi-dimensional detection:
   ```python
   # for (i=0; i<3; i++) for (j=0; j<4; j++) arr[i*4 + j]
   # → Detect outer loop bounds (3) and inner loop bounds (4)
   # → Reconstruct as arr[3][4]
   ```

5. Add confidence scoring:
   - 0.95: Explicit constant bound (i < 10)
   - 0.80: Inferred from usage (max observed index)
   - 0.60: Conservative estimate (max * 2 with TODO comment)

Why this approach: Loop bounds are the strongest evidence for array dimensions. Conservative estimates with TODO comments prevent crashes while flagging uncertainty.

What to avoid: Don't trust single-iteration patterns - require multiple accesses or explicit bounds. Don't assume unbounded arrays - always generate finite size.
  </action>
  <verify>
python -m pytest vcdecomp/tests/test_validation.py::test_decompilation_validation -v --log-cli-level=DEBUG 2>&1 | grep "Loop bound"

Log shows loop bound detection for arrays with min/max/step values.
  </verify>
  <done>
Loop bound analysis implemented with confidence scoring. Test validation log shows array dimension inference from loop patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement multi-dimensional array detection from indexing patterns</name>
  <files>vcdecomp/core/ir/structure/analysis/variables.py</files>
  <action>
Enhance variables.py array detection (existing code lines 165-253 per RESEARCH.md) to support multi-dimensional arrays:

1. Locate existing array detection code in _collect_local_variables()

2. Add pattern detection for nested indexing:
   ```python
   def _detect_multidim_pattern(memory_accesses: List[Instruction]) -> Optional[ArrayDims]:
       """Detect arr[i*width + j] → arr[i][j] patterns"""

       # Pattern: MUL(index1, const_width) + ADD(_, index2)
       # Example: i*4 + j where i=[0,3), j=[0,4) → arr[3][4]

       for access in memory_accesses:
           if access.mnemonic in ['ASP', 'SSP', 'LLD', 'LST']:
               # Check if offset uses multiplication pattern
               offset_expr = access.inputs[0]  # Offset calculation

               if is_mul_add_pattern(offset_expr):
                   outer_bound = extract_outer_index_bound(offset_expr)
                   inner_bound = extract_inner_index_bound(offset_expr)
                   width = extract_stride_constant(offset_expr)

                   return ArrayDims(
                       dimensions=[outer_bound, inner_bound],
                       element_size=4,  # From type inference
                       confidence=0.85
                   )
   ```

3. Calculate dimensions from stride analysis:
   - Stride 4 bytes with element_size=4 → 1D array
   - Stride 16 bytes with element_size=4 → arr[?][4] (stride/elem_size = inner dim)
   - Use loop bounds to resolve outer dimension

4. Integrate with existing size detection:
   - Keep existing allocation-based size calculation (lines 165-253)
   - Prefer loop bounds if available (higher confidence)
   - Fall back to allocation size / element_size for simple arrays

5. Add declaration formatting:
   ```python
   if len(dims) == 1:
       decl = f"{type_str} {var_name}[{dims[0]}]"
   elif len(dims) == 2:
       decl = f"{type_str} {var_name}[{dims[0]}][{dims[1]}]"
   elif len(dims) == 3:
       decl = f"{type_str} {var_name}[{dims[0]}][{dims[1]}][{dims[2]}]"

   if confidence < 0.70:
       decl += f" /* TODO: verify array size (confidence={confidence:.2f}) */"
   ```

Why this approach: arr[i*width + j] is the canonical multi-dimensional pattern in C bytecode. Stride analysis reveals inner dimension, loop bounds reveal outer dimension.

What to avoid: Don't assume row-major order without evidence. Don't generate 3D+ arrays speculatively - require clear nested patterns. Don't omit TODO comments on uncertain bounds.
  </action>
  <verify>
python -m pytest vcdecomp/tests/test_validation.py::test_decompilation_validation -v

Inspect .test_artifacts_07-04/ for array declarations:
- 1D arrays: `int arr[10]` with correct size
- 2D arrays: `float matrix[3][4]` from nested indexing
- TODO comments on uncertain bounds (confidence < 0.70)

Check test1/test2/test3 decompiled output for improvement vs generic "dword tmp[1]"
  </verify>
  <done>
Multi-dimensional array detection implemented. Decompiled output shows arr[x][y] declarations with dimensions from loop bounds and stride analysis. TODO comments flag uncertain sizes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate array reconstruction with compilation tests</name>
  <files>vcdecomp/tests/test_validation.py</files>
  <action>
Validate array dimension fixes compile successfully:

1. Run decompilation on test1/test2/test3 with array detection
2. Capture output to .test_artifacts_07-04/
3. Manual inspection for array improvements:

   Expected fixes from ERROR_BASELINE.md:
   - Multi-value assignments to same variable (Pattern 4) may be arrays
   - Struct field accesses at regular offsets may be arrays within structs
   - Loop-based accesses should generate array[i] not tmp_X

4. Create comparison document: .test_artifacts_07-04/ARRAY_RECONSTRUCTION.md
   ```markdown
   # Array Reconstruction Validation

   ## Test1 Arrays
   | Variable | Before | After | Evidence |
   |----------|--------|-------|----------|
   | tmp5 | `s_SC_MP_EnumPlayers tmp5` (WRONG - struct) | `float tmp5[3]` (CORRECT - array) | Sequential assignments tmp5=30.0f, tmp5=10.0f, tmp5=20.0f |

   ## Test2 Arrays
   ...

   ## Compilation Results
   - SCMP.exe exit code: ...
   - Errors: ...
   - Array-related errors reduced: X → Y (Z% reduction)
   ```

5. Attempt compilation:
   - Compare error count vs Plan 07-02 baseline
   - Check for array-related errors (bounds, dimensions)
   - Document remaining issues for control flow phase

Why this approach: Array bugs may masquerade as type mismatches (Pattern 2) or nonsensical assignments (Pattern 4). Systematic comparison proves array detection works.

What to avoid: Don't expect 100% array detection - some may remain scalar. Focus on clear loop-based patterns and multi-value assignments.
  </action>
  <verify>
cat C:/Users/flori/source/repos/VC_Scripter/.test_artifacts_07-04/ARRAY_RECONSTRUCTION.md

Report exists with before/after array comparisons and compilation results.
  </verify>
  <done>
Array reconstruction validated. Report shows dimension improvements, compilation results, and array-related error reduction vs baseline.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:

1. Loop bound analysis detects array dimensions from iteration patterns
2. Multi-dimensional arrays detected from stride/MUL+ADD patterns
3. Array declarations generated with correct dimensions and types
4. Uncertain bounds flagged with TODO comments
5. Compilation shows improvement in array-related errors
</verification>

<success_criteria>
Measurable completion:

1. Loop bound analysis logs dimension inference with confidence scores
2. Multi-dimensional arrays appear in decompiled output (arr[x][y] format)
3. Array declarations use types from Plan 07-02 (not generic dword)
4. ARRAY_RECONSTRUCTION.md shows systematic before/after comparison
5. Compilation attempt produces fewer array-related errors than Plan 07-02 baseline
</success_criteria>

<output>
After completion, create `.planning/phases/07-variable-declaration-fixes/07-04-SUMMARY.md`
</output>
