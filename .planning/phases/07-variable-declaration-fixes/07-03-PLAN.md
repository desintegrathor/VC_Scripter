---
phase: 07-variable-declaration-fixes
plan: 03
type: execute
wave: 3
depends_on: [07-01, 07-02]
files_modified:
  - vcdecomp/core/ir/global_resolver.py
  - vcdecomp/core/headers/database.py
  - vcdecomp/tests/test_validation.py
autonomous: true

must_haves:
  truths:
    - "Global variables detected using GADR/GLD opcodes with correct byte offset conversion"
    - "Global names sourced from save_info section (debug symbols) when available"
    - "Global types inferred from type_inference results (not generic 'dword')"
  artifacts:
    - path: "vcdecomp/core/ir/global_resolver.py"
      provides: "Global detection with type integration"
      contains: "_infer_global_types"
    - path: "vcdecomp/core/headers/database.py"
      provides: "SGI constant definitions"
      exports: ["get_sgi_constants", "resolve_sgi_value"]
  key_links:
    - from: "global_resolver.py"
      to: "type_inference results"
      via: "infer_types() dictionary"
      pattern: "inferred_types\\.get\\("
    - from: "global_resolver.py"
      to: "save_info globals"
      via: "Debug symbol names"
      pattern: "save_info.*globals"
---

<objective>
Fix global variable detection, naming, and type inference.

Purpose: Global variables currently suffer from offset confusion (DWORD vs BYTE), generic types, and synthetic names. This plan fixes global detection using opcodes + save_info + type inference integration.

Output: Global variable declarations with correct names (from debug symbols), accurate types (from type inference), and proper offset handling.
</objective>

<execution_context>
@C:\Users\flori\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\flori\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\Users\flori\source\repos\VC_Scripter\.planning\PROJECT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\ROADMAP.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\STATE.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-CONTEXT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-RESEARCH.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-01-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-02-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\global_resolver.py
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\headers\database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix global offset handling and integrate type inference</name>
  <files>vcdecomp/core/ir/global_resolver.py</files>
  <action>
Fix offset confusion and integrate type inference in global_resolver.py (combines original Tasks 1-2):

1. Locate _infer_global_types() method (around line 461-530 per RESEARCH.md)
2. Verify and fix DWORD-to-BYTE conversion:
   ```python
   # CRITICAL: GADR/GCP arg1 is DWORD offset, globals dict uses BYTE offset
   byte_offset = inst.arg1 * 4
   ```
3. Add validation logging:
   ```python
   logger.debug(f"Global access: opcode={inst.mnemonic}, dword_offset={inst.arg1}, byte_offset={byte_offset}")
   ```
4. Check all global access points (GADR, GCP, GLD, GST) use correct conversion
5. Audit globals dictionary keys - ensure all use byte offsets consistently
6. Add assertion: `assert byte_offset % 4 == 0, "Global byte offset must be 4-byte aligned"`

7. Modify _infer_global_types() to accept TypeInferenceEngine results:
   ```python
   def _infer_global_types(self, type_engine: TypeInferenceEngine):
       inferred_types = type_engine.infer_types()  # Dict[var_name, type_str]

       for inst in instructions:
           if inst.mnemonic in ['GCP', 'GLD', 'GADR', 'GST']:
               byte_offset = inst.arg1 * 4
               output_value = inst.outputs[0] if inst.outputs else None

               if output_value:
                   inferred_type = inferred_types.get(output_value.name)

                   # Skip void* from address ops (existing logic)
                   if inferred_type not in ['void*', 'ptr', None]:
                       self.globals[byte_offset].inferred_type = inferred_type
                       logger.debug(f"Global {byte_offset}: type={inferred_type}")
   ```
8. Add fallback: if type_inference returns None, keep existing type (don't overwrite with UNKNOWN)
9. Handle SGI constants: if value is SGI constant, use SGI type from headers
10. Update callers to pass TypeInferenceEngine instance

Why this approach: RESEARCH.md identifies offset conversion as a critical bug. Combining Tasks 1-2 reduces file churn - both modify _infer_global_types(). Reuses type_inference results from Plan 07-01 for consistency with locals.

What to avoid: Don't change globals dict structure - code expects byte offsets. Don't skip validation - silent corruption is worse than crashes. Don't skip address ops (GCP, GADR) - they load addresses, but the pointed-to value has a type.
  </action>
  <verify>
python -m pytest vcdecomp/tests/test_validation.py::test_decompilation_validation -v --log-cli-level=DEBUG 2>&1 | grep "Global"

Log shows:
- Correct DWORDâ†’BYTE conversion for each global access
- No assertion failures on alignment
- Global variables assigned types from type inference (float, int, struct types) not generic 'dword'
  </verify>
  <done>
Global offset handling validated with DWORD-to-BYTE conversion logging. All global accesses use byte offsets consistently with 4-byte alignment. Global variables have inferred types from type_inference results.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance global naming with save_info and SGI integration</name>
  <files>vcdecomp/core/ir/global_resolver.py</files>
  <action>
Improve global variable naming with debug symbols and SGI constants:

1. Check if save_info section exists and has globals:
   ```python
   if hasattr(script, 'save_info') and script.save_info.globals:
       for byte_offset, global_info in script.save_info.globals.items():
           if byte_offset in self.globals:
               self.globals[byte_offset].name = global_info.name
               self.globals[byte_offset].source = "save_info"
               logger.info(f"Global {byte_offset}: name from save_info: {global_info.name}")
   ```
2. Add SGI constant resolution (from headers database):
   ```python
   from ..headers.database import HeaderDatabase

   def _resolve_sgi_constants(self, header_db: HeaderDatabase):
       sgi_constants = header_db.get_sgi_constants()
       for byte_offset, global_var in self.globals.items():
           # Check if this offset matches an SGI constant
           for const_name, const_value in sgi_constants.items():
               if const_value == byte_offset:
                   global_var.name = const_name
                   global_var.source = "SGI_constant"
                   break
   ```
3. Naming priority: save_info (highest) > SGI constants > synthetic data_X (fallback)
4. Add source tracking: global_var.source = "save_info" | "SGI_constant" | "synthetic"

Why this approach: CONTEXT.md specifies save_info as highest priority source. SGI constants are game engine globals (sc_def.h). Synthetic names only for unknowns.

What to avoid: Don't overwrite save_info names with synthetic names. Don't skip SGI lookup - these are documented engine globals.
  </action>
  <verify>
python -m pytest vcdecomp/tests/test_validation.py::test_decompilation_validation -v --log-cli-level=INFO 2>&1 | grep "Global.*: name from"

Log shows:
- save_info names loaded for test1/test2 (have debug symbols)
- SGI constant names resolved for engine globals
- Synthetic names only for unresolved globals

Inspect decompiled output for meaningful global names (not just data_X for everything).
  </verify>
  <done>
Global variables named from save_info (debug symbols) and SGI constants (headers). Synthetic names used only as fallback. Log shows naming sources for each global.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:

1. Global offset handling uses correct DWORD-to-BYTE conversion
2. Global types inferred from type_inference results (not generic)
3. Global names sourced from save_info > SGI > synthetic priority
4. No regression in local variable fixes from Plan 07-02
5. Decompiled output shows meaningful global names and types
</verification>

<success_criteria>
Measurable completion:

1. Global offset conversion validated with debug logging and assertions
2. Global types show float/int/struct from type inference (not all 'dword')
3. Global names from save_info appear in test1/test2 output
4. SGI constant names appear in decompiled output (e.g., known engine globals)
5. No offset-related crashes or misaligned access errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-variable-declaration-fixes/07-03-SUMMARY.md`
</output>
