---
phase: 07-variable-declaration-fixes
plan: 12
type: execute
wave: 12
depends_on: [07-11]
files_modified:
  - vcdecomp/core/ir/structure/analysis/variables.py
  - vcdecomp/core/ir/structure/emit/block_formatter.py
autonomous: true
gap_closure: true
requires_git_bash: true

must_haves:
  truths:
    - "Variables are not used before initialization (SSA phi nodes resolve to safe defaults)"
    - "Unreachable code after return statements is completely eliminated"
    - "Code compiles with reduced compiler warnings"
  artifacts:
    - path: "vcdecomp/core/ir/structure/analysis/variables.py"
      provides: "Uninitialized variable detection and warnings"
      min_lines: 700
      exports: ["collect_and_declare_variables"]
    - path: "vcdecomp/core/ir/structure/emit/block_formatter.py"
      provides: "Complete unreachable code elimination"
      min_lines: 500
      exports: ["format_block"]
    - path: ".test_artifacts_07-12/uninit_vars_report.txt"
      provides: "Uninitialized variable analysis"
      contains: "Uninitialized: 0"
    - path: ".test_artifacts_07-12/unreachable_code_report.txt"
      provides: "Unreachable code validation"
      contains: "Unreachable statements: 0"
  key_links:
    - from: "variables.py SSA phi resolution"
      to: "Variable declaration with safe defaults"
      via: "Phi nodes without predecessors get default values"
      pattern: "phi.*default"
    - from: "block_formatter.py return detection"
      to: "Stop emitting after return"
      via: "Track return_seen flag per block"
      pattern: "return_seen.*=.*True"
---

<objective>
Eliminate remaining compilation warnings: uninitialized variables (Category 4) and unreachable code after returns (Category 5).

Purpose: Gap 2 Categories 4 & 5 cause compiler warnings and potential semantic errors. Category 4 shows tmp1, tmp2, tmp4 used before assignment. Category 5 shows residual unreachable code despite 07-07 fix. These are non-critical but reduce code quality.

Output: Clean code with initialized variables and no dead code after returns.
</objective>

<execution_context>
@C:\Users\flori\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\flori\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\Users\flori\source\repos\VC_Scripter\.planning\PROJECT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\ROADMAP.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\STATE.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-VERIFICATION.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-09-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-11-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\structure\analysis\variables.py
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\structure\emit\block_formatter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Variables at Declaration</name>
  <files>vcdecomp/core/ir/structure/analysis/variables.py</files>
  <action>
Add safe default initialization for variables that may be used before assignment.

**Problem from 07-09-SUMMARY.md:**
- Line 135: tmp1 used in condition before assignment
- Line 136: tmp2 used in assignment before initialization
- Lines 161-166: tmp2, tmp4 used before assignment

**Root cause:** SSA phi nodes at block entry may not have incoming values from all predecessors (e.g., when predecessor is unreachable).

**Fix strategy:**

1. **Identify variables needing initialization:**
```python
def _identify_uninit_vars(self, ssa: SSATransformer) -> Set[str]:
    """Find variables used before definite assignment."""
    uninit_vars = set()

    for block_id, block_ssa in ssa.blocks.items():
        for var_name, phi_node in block_ssa.phi_nodes.items():
            # Phi node with < expected incoming values indicates potential uninit
            expected_predecessors = len(block_ssa.predecessors)
            actual_incoming = len(phi_node.incoming_values)

            if actual_incoming < expected_predecessors:
                # Some paths don't define this variable
                uninit_vars.add(var_name)

    return uninit_vars
```

2. **Apply safe defaults during declaration:**
```python
def collect_and_declare_variables(self, blocks, ssa, formatter):
    """Generate variable declarations with initialization."""

    # Existing variable collection
    var_types = self._determine_var_types(...)

    # NEW: Identify potentially uninitialized variables
    uninit_vars = self._identify_uninit_vars(ssa) if ssa else set()

    declarations = []
    for var_name, var_type in var_types.items():
        # Add initialization for potentially uninitialized vars
        if var_name in uninit_vars:
            # Safe default based on type
            if var_type in {"int", "dword", "short", "char"}:
                init_value = " = 0"
            elif var_type == "float":
                init_value = " = 0.0f"
            elif var_type == "double":
                init_value = " = 0.0"
            else:
                # Struct/pointer types - null pointer
                init_value = " = {0}"  # Zero-initialize structs

            declarations.append(f"{var_type} {var_name}{init_value};")
        else:
            # Normal declaration without initialization
            declarations.append(f"{var_type} {var_name};")

    return declarations
```

3. **Alternative: Assignment-based detection:**
If SSA analysis too complex, use simpler heuristic:
```python
# Track variable assignments during code emission
# Warn if variable used in expression before any assignment
# Not as precise as SSA, but catches obvious cases
```

**Why this works:**
- Safe defaults (0, 0.0f, {0}) prevent undefined behavior
- Compiler warnings eliminated for "may be used uninitialized"
- Slight overhead of initialization, but ensures correctness
  </action>
  <verify>
NOTE: Requires Git Bash (bash.exe) available in PATH.

```bash
cd "C:\Users\flori\source\repos\VC_Scripter"
mkdir -p .test_artifacts_07-12

# Decompile with initialization
python -m vcdecomp structure "decompiler_source_tests/test1/tt.scr" > .test_artifacts_07-12/test1_init.c 2>&1

# Check tmp variable declarations
echo "=== tmp variable declarations ===" > .test_artifacts_07-12/uninit_vars_report.txt
grep "tmp[0-9]" .test_artifacts_07-12/test1_init.c | grep -E "int|float|dword" | head -20 >> .test_artifacts_07-12/uninit_vars_report.txt

# Look for initialized variables (= 0 pattern)
echo "" >> .test_artifacts_07-12/uninit_vars_report.txt
echo "=== Initialized variables ===" >> .test_artifacts_07-12/uninit_vars_report.txt
grep " = 0" .test_artifacts_07-12/test1_init.c | head -10 >> .test_artifacts_07-12/uninit_vars_report.txt

# Count potentially uninitialized (heuristic: declared but no initialization)
echo "" >> .test_artifacts_07-12/uninit_vars_report.txt
echo "=== Summary ===" >> .test_artifacts_07-12/uninit_vars_report.txt
echo "Uninitialized: Expected 0 (all variables initialized or proven safe by SSA)" >> .test_artifacts_07-12/uninit_vars_report.txt

cat .test_artifacts_07-12/uninit_vars_report.txt
```
  </verify>
  <done>
- variables.py adds safe default initialization for phi nodes with missing incoming values
- test1_init.c shows variables initialized (e.g., "int tmp1 = 0;")
- uninit_vars_report.txt shows initialization evidence
- No compiler warnings about uninitialized variables when compiled
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete Unreachable Code Elimination</name>
  <files>vcdecomp/core/ir/structure/emit/block_formatter.py</files>
  <action>
Fix residual unreachable code after return statements (07-07 incomplete fix).

**Problem from 07-09-SUMMARY.md:**
- Lines 141-144 in func_0050: Code after `return TRUE;`
- Line 168 in func_0119: `return;` after explicit returns

**Root cause:** 07-07 added return detection but may not handle all return patterns (TRUE/FALSE constants vs 0/1).

**Investigation:**

1. **Check existing 07-07 implementation:**
```bash
grep -A 10 "return_seen" vcdecomp/core/ir/structure/emit/block_formatter.py
```

2. **Likely issue:** Return detection doesn't catch all return expressions.

**Enhanced fix:**

```python
def format_statements(self, statements: List[str]) -> List[str]:
    """Format statements with unreachable code elimination."""
    formatted = []
    return_seen = False

    for stmt in statements:
        # Skip statements after return
        if return_seen:
            logger.debug(f"Skipping unreachable: {stmt}")
            continue

        formatted.append(stmt)

        # Detect return statements (ALL patterns)
        # Pattern 1: "return;"
        # Pattern 2: "return <value>;"
        # Pattern 3: "return TRUE/FALSE;"
        if stmt.strip().startswith("return"):
            return_seen = True
            logger.debug("Return detected - suppressing subsequent statements")

    return formatted
```

**Key improvement:** Use `stmt.strip().startswith("return")` to catch ALL return patterns, not just specific constants.

3. **Block-level return propagation:**
```python
def format_block(self, block_id: int) -> str:
    """Format single block with return awareness."""
    statements = []
    return_seen = False

    for instr in block.instructions:
        if return_seen:
            continue  # Skip all instructions after return

        stmt = self.format_instruction(instr)
        statements.append(stmt)

        if "return" in stmt:
            return_seen = True

    return "\n".join(statements)
```

**Why this works:**
- Generic return detection catches TRUE, FALSE, 0, NULL, etc.
- Block-level tracking prevents emitting any code after return
- Debug logging for diagnostics without polluting output
  </action>
  <verify>
NOTE: Requires Git Bash (bash.exe) available in PATH.

```bash
cd "C:\Users\flori\source\repos\VC_Scripter"

# Decompile with complete unreachable elimination
python -m vcdecomp structure "decompiler_source_tests/test1/tt.scr" > .test_artifacts_07-12/test1_no_unreachable.c 2>&1

# Check func_0050 for unreachable code (known issue lines 141-144)
echo "=== func_0050 unreachable check ===" > .test_artifacts_07-12/unreachable_code_report.txt
grep -A 30 "func_0050" .test_artifacts_07-12/test1_no_unreachable.c | grep -A 5 "return" >> .test_artifacts_07-12/unreachable_code_report.txt

# Search for code after returns in entire file
echo "" >> .test_artifacts_07-12/unreachable_code_report.txt
echo "=== Statements after returns ===" >> .test_artifacts_07-12/unreachable_code_report.txt

# Strategy: Find "return" lines, check if next non-blank line is close brace or another statement
# Simplified: Just count lines after return before close brace
python3 -c "
import re
with open('.test_artifacts_07-12/test1_no_unreachable.c') as f:
    lines = f.readlines()

unreachable_count = 0
after_return = False
for line in lines:
    if 'return' in line and line.strip().endswith(';'):
        after_return = True
    elif after_return:
        if line.strip() == '}':
            after_return = False
        elif line.strip() and not line.strip().startswith('//'):
            unreachable_count += 1
            print(f'Unreachable: {line.strip()}')

print(f'Total unreachable statements: {unreachable_count}')
" >> .test_artifacts_07-12/unreachable_code_report.txt 2>&1

cat .test_artifacts_07-12/unreachable_code_report.txt
```
  </verify>
  <done>
- block_formatter.py return detection enhanced to catch all return patterns
- test1_no_unreachable.c has NO code after return statements
- unreachable_code_report.txt shows "Unreachable statements: 0"
- func_0050 lines 141-144 eliminated (code after return TRUE)
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate Categories 4 & 5 Elimination</name>
  <files>.test_artifacts_07-12/categories45_report.txt</files>
  <action>
Comprehensive validation of uninitialized variable and unreachable code fixes.

**Validation steps:**

1. **Category 4 validation (uninitialized variables):**
```bash
cd "C:\Users\flori\source\repos\VC_Scripter"

echo "=== Categories 4 & 5 Validation ===" > .test_artifacts_07-12/categories45_report.txt
echo "" >> .test_artifacts_07-12/categories45_report.txt

# Decompile all tests
python -m vcdecomp structure "decompiler_source_tests/test1/tt.scr" > .test_artifacts_07-12/test1_final.c 2>&1
python -m vcdecomp structure "decompiler_source_tests/test2/tdm.scr" > .test_artifacts_07-12/test2_final.c 2>&1
python -m vcdecomp structure "decompiler_source_tests/test3/LEVEL.SCR" > .test_artifacts_07-12/test3_final.c 2>&1

echo "Category 4: Uninitialized Variables" >> .test_artifacts_07-12/categories45_report.txt
echo "---" >> .test_artifacts_07-12/categories45_report.txt

# Check specific variables from 07-09 (tmp1, tmp2, tmp4)
echo "test1 tmp1 declaration:" >> .test_artifacts_07-12/categories45_report.txt
grep "int tmp1" .test_artifacts_07-12/test1_final.c | head -1 >> .test_artifacts_07-12/categories45_report.txt || echo "  Not found" >> .test_artifacts_07-12/categories45_report.txt

echo "test1 tmp2 declaration:" >> .test_artifacts_07-12/categories45_report.txt
grep "int tmp2" .test_artifacts_07-12/test1_final.c | head -1 >> .test_artifacts_07-12/categories45_report.txt || echo "  Not found" >> .test_artifacts_07-12/categories45_report.txt

echo "test1 tmp4 declaration:" >> .test_artifacts_07-12/categories45_report.txt
grep "int tmp4" .test_artifacts_07-12/test1_final.c | head -1 >> .test_artifacts_07-12/categories45_report.txt || echo "  Not found" >> .test_artifacts_07-12/categories45_report.txt

# Count initialized vs uninitialized
echo "" >> .test_artifacts_07-12/categories45_report.txt
echo "Initialized variables (= 0 pattern):" >> .test_artifacts_07-12/categories45_report.txt
grep -c " = 0;" .test_artifacts_07-12/test1_final.c >> .test_artifacts_07-12/categories45_report.txt || echo "0" >> .test_artifacts_07-12/categories45_report.txt
```

2. **Category 5 validation (unreachable code):**
```bash
echo "" >> .test_artifacts_07-12/categories45_report.txt
echo "Category 5: Unreachable Code After Returns" >> .test_artifacts_07-12/categories45_report.txt
echo "---" >> .test_artifacts_07-12/categories45_report.txt

# Check func_0050 (known to have unreachable lines 141-144)
echo "func_0050 unreachable code check:" >> .test_artifacts_07-12/categories45_report.txt
grep -A 10 "func_0050" .test_artifacts_07-12/test1_final.c | grep -A 3 "return" | tail -3 >> .test_artifacts_07-12/categories45_report.txt

# If next lines after return are close brace, unreachable code eliminated
# If next lines are statements, unreachable code remains

echo "" >> .test_artifacts_07-12/categories45_report.txt
echo "func_0119 unreachable code check:" >> .test_artifacts_07-12/categories45_report.txt
grep -A 10 "func_0119" .test_artifacts_07-12/test1_final.c | grep -A 3 "return" | tail -3 >> .test_artifacts_07-12/categories45_report.txt
```

3. **Summary:**
```bash
echo "" >> .test_artifacts_07-12/categories45_report.txt
echo "=== SUMMARY ===" >> .test_artifacts_07-12/categories45_report.txt
echo "Category 4: Expected all tmp variables initialized or proven safe" >> .test_artifacts_07-12/categories45_report.txt
echo "Category 5: Expected NO statements between return and close brace" >> .test_artifacts_07-12/categories45_report.txt
echo "" >> .test_artifacts_07-12/categories45_report.txt
echo "Status: Categories 4 & 5 eliminated (non-critical warnings resolved)" >> .test_artifacts_07-12/categories45_report.txt

cat .test_artifacts_07-12/categories45_report.txt
```
  </action>
  <verify>
NOTE: Requires Git Bash (bash.exe) available in PATH.

```bash
# Verify categories 4 & 5 fixes
cat .test_artifacts_07-12/categories45_report.txt

# Check for residual issues
echo ""
echo "=== Residual Issue Check ==="

# Category 4: Uninitialized variable usage
grep -n "tmp[0-9] = " .test_artifacts_07-12/test1_final.c | head -5

# Category 5: Code after returns
grep -A 2 "return.*;" .test_artifacts_07-12/test1_final.c | grep -v "^--$" | grep -v "return" | grep -v "^}" | head -5 || echo "No unreachable code found"
```
  </verify>
  <done>
- categories45_report.txt shows resolution of both categories
- tmp1, tmp2, tmp4 either initialized at declaration or proven safe by SSA
- No statements appear between return and close brace in any function
- Code quality improved, compiler warnings reduced
  </done>
</task>

</tasks>

<verification>
## Categories 4 & 5 Elimination Verification

**Success Criteria:**
1. No uninitialized variable compiler warnings
2. No unreachable code after return statements
3. Clean SCMP.exe compilation output (warnings reduced)

**Verification Commands:**
```bash
# Category 4: Check variable initialization
grep "tmp[0-9]" .test_artifacts_07-12/test1_final.c | grep "= 0" | wc -l
# Expected: Count of initialized variables

# Category 5: Check for unreachable code
grep -A 2 "return" .test_artifacts_07-12/test1_final.c | grep -v "return" | grep -v "^}" | wc -l
# Expected: 0 (no statements after return)
```

**Manual Inspection:**
1. Open .test_artifacts_07-12/test1_final.c
2. Find func_0050 - verify no code after line 140 (return TRUE)
3. Find func_0119 - verify no code after line 162/166 returns
4. Check tmp variable declarations - verify initialization or safe SSA

</verification>

<success_criteria>
## Gap 2 Categories 4 & 5 Eliminated

**Measurable Outcomes:**
1. Uninitialized variables: 0 instances (safe defaults or SSA-proven safe)
2. Unreachable code after returns: 0 statements
3. Compiler warning count reduced significantly

**Acceptance Test:**
```bash
# Test for unreachable code
python -m vcdecomp structure "decompiler_source_tests/test1/tt.scr" > /tmp/test1_check.c
grep -A 1 "return.*;" /tmp/test1_check.c | grep -v "return" | grep -v "^}" | grep -v "^--$" && echo "FAILED: Unreachable code remains" || echo "PASSED: No unreachable code"

# Expected: "PASSED: No unreachable code"
```

**Next Steps:**
- Plan 07-13: Compilation validation with SCMP.exe (final gap closure verification)
</success_criteria>

<output>
After completion, create `.planning/phases/07-variable-declaration-fixes/07-12-SUMMARY.md` with:
- Uninitialized variable detection and initialization strategy
- Unreachable code elimination completion (07-07 fix enhancement)
- Validation evidence showing 0 instances of both categories
- Compiler warning reduction analysis
</output>
