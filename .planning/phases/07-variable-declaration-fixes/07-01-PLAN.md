---
phase: 07-variable-declaration-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vcdecomp/core/ir/type_inference.py
  - vcdecomp/core/ir/stack_lifter.py
  - vcdecomp/tests/test_validation.py
autonomous: true

must_haves:
  truths:
    - "Type inference engine integrates with stack lifter during SSA construction"
    - "SSA values have accurate initial types from opcodes (FADD→float, IADD→int)"
    - "Type propagation flows forward through assignments (a=b → type(a)=type(b))"
  artifacts:
    - path: "vcdecomp/core/ir/stack_lifter.py"
      provides: "Type hints from opcodes during SSA construction"
      min_lines: 800
    - path: "vcdecomp/core/ir/type_inference.py"
      provides: "Two-pass integration: initial types + dataflow refinement"
      min_lines: 700
  key_links:
    - from: "stack_lifter.py"
      to: "type_inference.py"
      via: "SSAValue.value_type field"
      pattern: "value\\.value_type.*ResultType"
    - from: "type_inference.py"
      to: "SSAValue objects"
      via: "Type refinement updates SSA values"
      pattern: "value\\.value_type\\s*="
---

<objective>
Integrate type inference engine with stack lifter to fix Pattern 2 type mismatches at the source.

Purpose: Phase 6 deferred Pattern 2 (type mismatches) because stack_lifter assigns UNKNOWN types too often. This plan fixes type assignment during SSA construction by integrating type_inference.py opcode analysis directly into stack_lifter.py, ensuring accurate initial types before downstream processing.

Output: SSA values with correct initial types from opcodes, enabling accurate variable declarations downstream.
</objective>

<execution_context>
@C:\Users\flori\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\flori\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\Users\flori\source\repos\VC_Scripter\.planning\PROJECT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\ROADMAP.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\STATE.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-CONTEXT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-RESEARCH.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\06-expression-reconstruction-fixes\ERROR_BASELINE.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\06-expression-reconstruction-fixes\06-05-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\stack_lifter.py
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\type_inference.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance stack_lifter with opcode-based type hints</name>
  <files>vcdecomp/core/ir/stack_lifter.py</files>
  <action>
Modify stack_lifter.py to assign accurate initial types during SSA construction based on opcode evidence:

1. Import TypeInferenceEngine and ResultType mappings from type_inference.py
2. Add type hint extraction method:
   - Map float opcodes (FADD, FSUB, FMUL, FDIV, FNEG) → ResultType.FLOAT
   - Map int opcodes (IADD, ISUB, IMUL, IDIV, IMOD) → ResultType.INT
   - Map conversion opcodes (ITOF, FTOI, CTOI, etc.) → explicit output type (99% confidence)
   - Map comparison opcodes (FCL, FEQ, ICL, etc.) → ResultType.INT (boolean)
3. Update _simulate_instruction() to apply type hints when creating SSA values:
   ```python
   # Set value.value_type = inferred_result_type when creating SSA values
   value.value_type = inferred_result_type  # Example wiring point
   ```
4. Preserve existing UNKNOWN assignments for genuinely ambiguous operations (GCP, LCP without dereference)
5. Add logging: "Stack lifter assigned type {type} to {value} based on opcode {mnemonic}"

Why this approach: Type inference already has robust opcode-to-type mappings (type_inference.py:250-274). We're bringing that logic forward to SSA construction instead of compensating downstream.

What to avoid: Don't replace type_inference.py - stack_lifter provides initial hints, type_inference.py still refines via dataflow propagation.
  </action>
  <verify>
python -m pytest vcdecomp/tests/test_validation.py::test_decompilation_validation -v --log-cli-level=INFO 2>&1 | grep "Stack lifter assigned type"

Check log output shows:
- FLOAT assignments for FADD/FSUB/FMUL/FDIV operations
- INT assignments for IADD/ISUB/IMUL/IDIV operations
- Explicit types for conversion opcodes
  </verify>
  <done>
SSA values produced by stack_lifter have accurate initial value_type assignments based on opcode evidence. Test validation log shows type assignments from stack lifter (not 100% UNKNOWN).
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement two-pass type inference integration</name>
  <files>vcdecomp/core/ir/type_inference.py</files>
  <action>
Modify type_inference.py to integrate with stack_lifter's initial types:

1. Add method: integrate_with_ssa_values(ssa_func: SSAFunction) → None
   - Accept initial types from SSA values as evidence (confidence 0.85 - lower than conversions but higher than propagation)
   - Run dataflow propagation to refine types
   - Update SSA value.value_type fields with refined types (write back to SSA)
2. Add evidence source: TypeSource.SSA_INITIAL for stack_lifter hints
3. Update _resolve_types() to prefer high-confidence evidence:
   - Conversion opcodes (0.99) > Function signatures (0.98) > SSA initial (0.85) > Instruction opcodes (0.80) > Propagation (0.70)
4. Handle PHI nodes: merge conflicting types with confidence penalty (existing logic)
5. Add logging: "Type inference refined {value}: {initial_type} → {final_type} (confidence {conf})"

Why this approach: Two-pass design - stack_lifter provides fast initial types, type_inference refines with dataflow. Write-back to SSA ensures downstream modules (variables.py) see refined types.

What to avoid: Don't discard stack_lifter types - they're valuable evidence. Don't assume type_inference is always right - use confidence scoring to resolve conflicts.
  </action>
  <verify>
python -m pytest vcdecomp/tests/test_validation.py::test_decompilation_validation -v --log-cli-level=INFO 2>&1 | grep "Type inference refined"

Check log output shows:
- Refinements where propagation improved initial types
- SSA values updated with final types
- Confidence scores logged
  </verify>
  <done>
Type inference engine accepts SSA initial types as evidence, runs dataflow propagation, and writes refined types back to SSA values. Log shows refinement process with confidence scores.
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate Pattern 2 type mismatch reduction</name>
  <files>vcdecomp/tests/test_validation.py</files>
  <action>
Run validation tests and measure Pattern 2 (type mismatch) reduction:

1. Run decompilation on test1/test2/test3 with new type integration
2. Capture decompiled output to files: test1_integrated.c, test2_integrated.c, test3_integrated.c
3. Search decompiled output for ERROR_BASELINE.md Pattern 2 signatures:
   - Lines 59-94 describe Pattern 2: type mismatch in variable assignments
   - Example 1 (lines 67-72): tmp5 declared as struct but assigned float from SC_ggf(400) and 30.0f
   - Example 2 (lines 76-81): tmp6 declared as struct but assigned int and float values (5.0f, 10.0f)
   - Example 3 (lines 83-86): tmp declared as int but dereferenced and assigned -20000.0f
4. Count Pattern 2 instances using methodology:
   - Search for struct-typed variables assigned primitive values (float/int literals or function returns)
   - Search for primitive-typed variables assigned incompatible types (int assigned float)
   - Search for pointer dereference mismatches (*int_var = float_value)
   - Record counts in pattern2_comparison.txt with line references to ERROR_BASELINE.md
5. Compare baseline vs new output:
   - Pattern 2 instances before: X (from ERROR_BASELINE.md count)
   - Pattern 2 instances after: Y (from new decompiled output)
   - Reduction: (X-Y)/X * 100%
6. Create summary: "Type integration reduced Pattern 2 by Z%"

Why this approach: Pattern 2 is the validation test from Phase 6. Reduction proves type integration is working. Manual inspection required since compiler crashes prevent automated error categorization.

What to avoid: Don't expect 100% elimination - some type mismatches may require variable.py changes (next plans). Focus on measuring improvement.
  </action>
  <verify>
ls C:/Users/flori/source/repos/VC_Scripter/.test_artifacts_07-01/*.c
cat C:/Users/flori/source/repos/VC_Scripter/.test_artifacts_07-01/pattern2_comparison.txt

Files exist with decompiled output and Pattern 2 reduction measurement. pattern2_comparison.txt contains:
- ERROR_BASELINE.md Pattern 2 line references (59-94)
- Specific signature searches (struct=float, int=float, pointer mismatches)
- Before/after counts
- Reduction percentage
  </verify>
  <done>
Validation tests produce decompiled C files with integrated type inference. Pattern 2 comparison document shows measurable reduction in type mismatches vs ERROR_BASELINE.md baseline (lines 59-94), with counting methodology documented.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:

1. Stack lifter assigns types based on opcodes (not just UNKNOWN)
2. Type inference integrates SSA initial types as evidence
3. Refined types written back to SSA values before declaration generation
4. Pattern 2 type mismatch instances reduced vs Phase 6 baseline
5. No regression in Phase 6 fixes (Pattern 1, 3, 5 still working)
</verification>

<success_criteria>
Measurable completion:

1. SSA values have value_type assigned from opcodes in >80% of cases (vs baseline ~20%)
2. Type inference logs show refinements with confidence scores
3. Pattern 2 instances reduced by >50% in test1/test2/test3 vs ERROR_BASELINE.md
4. Validation tests complete without crashes (compile errors acceptable, improvement measured)
5. Integration code committed with clear logging for debugging
</success_criteria>

<output>
After completion, create `.planning/phases/07-variable-declaration-fixes/07-01-SUMMARY.md`
</output>
