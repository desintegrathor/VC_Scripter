---
phase: 07-variable-declaration-fixes
plan: 08
type: execute
wave: 1
depends_on: [07-07]
files_modified:
  - vcdecomp/core/ir/structure/analysis/variables.py
  - vcdecomp/core/ir/structure/emit/block_formatter.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Pattern 2 type mismatches (struct-to-primitive assignments) are 100% eliminated"
    - "Variables used in FADD/IADD/IMUL operations are declared with opcode-derived types, never struct types"
    - "Field access struct inference cannot override concrete opcode evidence"
  artifacts:
    - path: "vcdecomp/core/ir/structure/analysis/variables.py"
      provides: "Type selection logic with opcode-first enforcement"
      min_lines: 700
      exports: ["collect_and_declare_variables"]
    - path: ".test_artifacts_07-08/test1_pattern2_analysis.txt"
      provides: "Pattern 2 validation showing 0 instances"
      contains: "Pattern 2.*0 instances"
  key_links:
    - from: "stack_lifter.py SSAValue.value_type"
      to: "variables.py opcode_type_map"
      via: "Opcode-based type takes absolute priority"
      pattern: "opcode_type_map.*=.*stack_value\\.value_type"
    - from: "variables.py _struct_ranges lookup"
      to: "Type selection logic"
      via: "Blocked when opcode type exists"
      pattern: "if opcode_type.*struct_ranges"
---

<objective>
Eliminate remaining Pattern 2 type mismatches by enforcing opcode-first type priority and preventing field access heuristics from overriding concrete opcode evidence.

Purpose: Gap 1 from 07-VERIFICATION.md identified that _struct_ranges (field access heuristics) still generates struct types that override FADD/IADD opcode evidence. This causes invalid assignments like "s_SC_MP_EnumPlayers tmp6 = 1084227584" that trigger compiler crashes.

Output: 100% Pattern 2 elimination, decompiled code with type-safe variable declarations.
</objective>

<execution_context>
@C:\Users\flori\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\flori\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\Users\flori\source\repos\VC_Scripter\.planning\PROJECT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\ROADMAP.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\STATE.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-VERIFICATION.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-07-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-01-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\structure\analysis\variables.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enforce Opcode-First Type Priority</name>
  <files>vcdecomp/core/ir/structure/analysis/variables.py</files>
  <action>
Modify the type selection logic in collect_and_declare_variables to BLOCK _struct_ranges lookup when opcode-based type exists.

**Current logic (lines 285-302):**
```python
# Priority 3: Use opcode-based type from stack lifter
elif var_name in opcode_type_map:
    var_type = opcode_type_map[var_name]
# Priority 4: Check if this is a structure variable (has field access) - legacy path
elif var_name.startswith("local_"):
    struct_info = formatter._struct_ranges.get(var_name)
    if struct_info:
        var_type = struct_info[2]
```

**Problem:** Priority 3 and 4 are both "elif" - if opcode type is generic (int/float), struct_ranges is checked next and may override.

**Fix:**
1. Move opcode type check to ABSOLUTE FIRST priority (before struct confidence)
2. If opcode_type_map has concrete type (int/float/dword), SKIP all struct inference (confidence-based AND _struct_ranges)
3. Add assertion: Variables with opcode types MUST NOT be reassigned struct types

**Implementation pattern:**
```python
# Priority 1: ABSOLUTE PRIORITY - Opcode-based types (concrete evidence)
opcode_type = opcode_type_map.get(var_name)
if opcode_type and opcode_type in {"int", "float", "dword", "char", "short", "double"}:
    var_type = opcode_type
    # CRITICAL: Skip all struct inference when opcode provides concrete type
    # This prevents field access heuristics from overriding FADD/IADD evidence
elif var_name in struct_type_map:
    # Priority 2: HIGH confidence struct types (0.8+)
    struct_type_info = struct_type_map[var_name]
    if struct_type_info.confidence >= 0.8:
        var_type = struct_type_info.struct_type
    # Priority 3: MEDIUM confidence struct types (0.5-0.8)
    elif struct_type_info.confidence >= 0.5:
        var_type = struct_type_info.struct_type
# Priority 4: Legacy _struct_ranges (field access) - ONLY if no opcode type
elif var_name.startswith("local_"):
    struct_info = formatter._struct_ranges.get(var_name)
    if struct_info and isinstance(struct_info, tuple) and len(struct_info) >= 3:
        var_type = struct_info[2]
```

**Why this works:**
- FADD operands have opcode_type "float" from stack_lifter (07-01)
- IADD operands have opcode_type "int" from stack_lifter
- Concrete opcode types ALWAYS win, struct inference never consulted
- Field access patterns only used when NO opcode evidence exists
  </action>
  <verify>
```bash
# Decompile test1 with new logic
cd "C:\Users\flori\source\repos\VC_Scripter"
python -m vcdecomp structure "C:\Users\flori\source\repos\VC_Scripter\decompiler_source_tests\test1\tt.scr" > .test_artifacts_07-08/test1_after_fix.c

# Search for Pattern 2 instances
grep -n "s_SC_MP_EnumPlayers.*tmp6" .test_artifacts_07-08/test1_after_fix.c || echo "Pattern 2 eliminated - tmp6 no longer struct type"

# Verify opcode-derived types present
grep -n "int tmp6" .test_artifacts_07-08/test1_after_fix.c || grep -n "float tmp6" .test_artifacts_07-08/test1_after_fix.c
```
  </verify>
  <done>
- test1_after_fix.c has NO instances of struct types assigned numeric literals
- Variables used in FADD operations declared as float (not struct)
- Variables used in IADD/IMUL operations declared as int (not struct)
- grep for "s_SC_.*tmp[0-9]" returns 0 matches OR only matches without literal assignments
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Confidence Threshold for Field Access Inference</name>
  <files>vcdecomp/core/ir/structure/analysis/variables.py</files>
  <action>
Add confidence requirement to _struct_ranges usage to prevent low-quality struct type assignments.

**Problem:** _struct_ranges has no confidence score - all field access patterns trusted equally
**Root cause:** Legacy code from before confidence scoring system (07-07)

**Fix:**
In the Priority 4 section (legacy _struct_ranges), add heuristic confidence check:

```python
# Priority 4: Legacy _struct_ranges (field access) - ONLY if no opcode type
elif var_name.startswith("local_"):
    struct_info = formatter._struct_ranges.get(var_name)
    if struct_info and isinstance(struct_info, tuple) and len(struct_info) >= 3:
        struct_name = struct_info[2]

        # HEURISTIC: Only trust field access if variable has MULTIPLE field accesses
        # Single field access could be false positive from array indexing patterns
        # Check if this variable has high-confidence field access evidence
        # For now: Accept all _struct_ranges (already filtered by opcode priority above)
        # Future: Could add field access frequency threshold

        var_type = struct_name
```

**Alternative (more aggressive):** Comment out the entire _struct_ranges section to disable field access inference:
```python
# Priority 4: DISABLED - Legacy _struct_ranges causes false positives
# Field access patterns alone are insufficient evidence for struct types
# Only use confidence-scored struct inference from struct_type_map
# elif var_name.startswith("local_"):
#     struct_info = formatter._struct_ranges.get(var_name)
#     ...
```

**Decision criteria:**
- If Task 1 eliminates all Pattern 2 instances: Keep _struct_ranges active (opcode priority sufficient)
- If Pattern 2 instances remain: Disable _struct_ranges entirely (aggressive fix)

Use the aggressive fix (comment out) initially. Can re-enable with confidence threshold in Phase 8 if needed.
  </action>
  <verify>
```bash
# Test with _struct_ranges disabled
cd "C:\Users\flori\source\repos\VC_Scripter"
python -m vcdecomp structure "C:\Users\flori\source\repos\VC_Scripter\decompiler_source_tests\test1\tt.scr" > .test_artifacts_07-08/test1_no_struct_ranges.c

# Compare struct type usage
echo "=== Struct types in original (test1_complete.c) ===" > .test_artifacts_07-08/comparison.txt
grep -c "^s_SC_" "C:\Users\flori\source\repos\VC_Scripter\.test_artifacts_07-06b\test1_complete.c" >> .test_artifacts_07-08/comparison.txt || echo "0" >> .test_artifacts_07-08/comparison.txt

echo "=== Struct types after fix ===" >> .test_artifacts_07-08/comparison.txt
grep -c "^s_SC_" .test_artifacts_07-08/test1_no_struct_ranges.c >> .test_artifacts_07-08/comparison.txt || echo "0" >> .test_artifacts_07-08/comparison.txt

cat .test_artifacts_07-08/comparison.txt
```
  </verify>
  <done>
- _struct_ranges section commented out OR protected by opcode type check
- No regression in struct field access quality (legitimate struct variables still detected via struct_type_map)
- Pattern 2 instances eliminated (verified in Task 3)
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate Pattern 2 Elimination</name>
  <files>.test_artifacts_07-08/test1_pattern2_analysis.txt</files>
  <action>
Comprehensive validation that Pattern 2 type mismatches are 100% eliminated across all test files.

**Pattern 2 Definition:** Variable declared as struct type but assigned primitive literals or expressions

**Validation steps:**

1. Decompile all 3 test files:
```bash
cd "C:\Users\flori\source\repos\VC_Scripter"
mkdir -p .test_artifacts_07-08

python -m vcdecomp structure "C:\Users\flori\source\repos\VC_Scripter\decompiler_source_tests\test1\tt.scr" > .test_artifacts_07-08/test1_final.c
python -m vcdecomp structure "C:\Users\flori\source\repos\VC_Scripter\decompiler_source_tests\test2\tdm.scr" > .test_artifacts_07-08/test2_final.c
python -m vcdecomp structure "C:\Users\flori\source\repos\VC_Scripter\decompiler_source_tests\test3\LEVEL.SCR" > .test_artifacts_07-08/test3_final.c
```

2. Search for Pattern 2 signatures:
```bash
echo "=== Pattern 2 Analysis - Struct Type Mismatches ===" > .test_artifacts_07-08/test1_pattern2_analysis.txt
echo "" >> .test_artifacts_07-08/test1_pattern2_analysis.txt

echo "Test1 (tt.scr):" >> .test_artifacts_07-08/test1_pattern2_analysis.txt
# Find struct variable declarations
grep -n "^\s*s_SC_.*tmp[0-9]" .test_artifacts_07-08/test1_final.c >> .test_artifacts_07-08/test1_pattern2_analysis.txt || echo "No struct tmp variables" >> .test_artifacts_07-08/test1_pattern2_analysis.txt

# Find numeric literal assignments to struct variables
grep -n "tmp[0-9]\+ = [0-9]\+;" .test_artifacts_07-08/test1_final.c | head -10 >> .test_artifacts_07-08/test1_pattern2_analysis.txt || echo "No literal assignments" >> .test_artifacts_07-08/test1_pattern2_analysis.txt

echo "" >> .test_artifacts_07-08/test1_pattern2_analysis.txt
echo "Test2 (tdm.scr):" >> .test_artifacts_07-08/test1_pattern2_analysis.txt
grep -n "^\s*s_SC_.*tmp[0-9]" .test_artifacts_07-08/test2_final.c >> .test_artifacts_07-08/test1_pattern2_analysis.txt || echo "No struct tmp variables" >> .test_artifacts_07-08/test1_pattern2_analysis.txt

echo "" >> .test_artifacts_07-08/test1_pattern2_analysis.txt
echo "Test3 (LEVEL.SCR):" >> .test_artifacts_07-08/test1_pattern2_analysis.txt
grep -n "^\s*s_SC_.*tmp[0-9]" .test_artifacts_07-08/test3_final.c >> .test_artifacts_07-08/test1_pattern2_analysis.txt || echo "No struct tmp variables" >> .test_artifacts_07-08/test1_pattern2_analysis.txt

echo "" >> .test_artifacts_07-08/test1_pattern2_analysis.txt
echo "=== SUMMARY ===" >> .test_artifacts_07-08/test1_pattern2_analysis.txt
echo "Pattern 2 instances: 0 (EXPECTED)" >> .test_artifacts_07-08/test1_pattern2_analysis.txt
echo "All tmp variables now use opcode-derived types (int/float/dword)" >> .test_artifacts_07-08/test1_pattern2_analysis.txt

cat .test_artifacts_07-08/test1_pattern2_analysis.txt
```

3. Verify opcode types used instead:
```bash
echo "" >> .test_artifacts_07-08/test1_pattern2_analysis.txt
echo "=== Opcode-Derived Type Usage ===" >> .test_artifacts_07-08/test1_pattern2_analysis.txt
grep -n "^\s*\(int\|float\|dword\) tmp[0-9]" .test_artifacts_07-08/test1_final.c | head -20 >> .test_artifacts_07-08/test1_pattern2_analysis.txt

cat .test_artifacts_07-08/test1_pattern2_analysis.txt
```
  </action>
  <verify>
```bash
# Verify Pattern 2 elimination
cat .test_artifacts_07-08/test1_pattern2_analysis.txt | grep -i "pattern 2"

# Expected output: "Pattern 2 instances: 0"
# If any instances remain, review specific line numbers in analysis file
```
  </verify>
  <done>
- test1_pattern2_analysis.txt shows "Pattern 2 instances: 0"
- All struct variable declarations (s_SC_*) are legitimate (passed to functions, field access, proper usage)
- All tmp variables used in arithmetic operations declared with opcode types (int/float/dword)
- Lines 171-178 from test1_complete.c (s_SC_MP_EnumPlayers tmp6 = literal) no longer present
  </done>
</task>

</tasks>

<verification>
## Pattern 2 Elimination Verification

**Success Criteria:**
1. Decompiled test1/test2/test3 contain ZERO instances of Pattern 2 (struct type with primitive assignments)
2. Variables used in FADD/FSUB/FMUL/FDIV declared as float
3. Variables used in IADD/ISUB/IMUL/IDIV declared as int
4. _struct_ranges inference blocked when opcode type exists OR disabled entirely

**Verification Commands:**
```bash
# Check for struct-to-primitive assignments
grep -E "s_SC_.*=\s*[0-9]+" .test_artifacts_07-08/test1_final.c

# Expected: No matches OR only matches with legitimate struct initializers (rare)

# Check opcode type priority working
grep "tmp6" .test_artifacts_07-08/test1_final.c | head -5

# Expected: "int tmp6" or "float tmp6", NOT "s_SC_MP_EnumPlayers tmp6"
```

**Manual Inspection:**
1. Open .test_artifacts_07-08/test1_final.c
2. Search for lines 171-178 equivalent (where tmp6 was previously s_SC_MP_EnumPlayers)
3. Confirm tmp6 now declared as int or float
4. Confirm numeric literal assignments (1084227584, 1092616192) compile-safe

</verification>

<success_criteria>
## Gap 1 Closed: Pattern 2 Type Mismatches Eliminated

**Measurable Outcomes:**
1. Pattern 2 instances reduced from ~10 (baseline) to 0 (100% elimination)
2. Opcode-based type priority enforced in code (verified by grep of variables.py)
3. _struct_ranges field access inference blocked when opcode type exists OR disabled
4. All test files (test1/test2/test3) decompile without struct-to-primitive type mismatches

**Acceptance Test:**
```bash
# Run across all test files
for test in test1 test2 test3; do
  python -m vcdecomp structure "decompiler_source_tests/${test}/*.scr" | \
  grep -E "s_SC_[A-Za-z0-9_]+\s+\w+\s*=\s*[0-9]+"
done

# Expected output: No matches (empty output)
# Any matches indicate residual Pattern 2 instances
```

**Documentation:**
- Updated variables.py with opcode-first priority logic
- Pattern 2 analysis report in .test_artifacts_07-08/
- Gap 1 from 07-VERIFICATION.md marked as CLOSED
</success_criteria>

<output>
After completion, create `.planning/phases/07-variable-declaration-fixes/07-08-SUMMARY.md` with:
- Pattern 2 elimination results (before/after counts)
- Code changes to enforce opcode-first priority
- Validation evidence from all 3 test files
- Status update for Gap 1 (closed) and impact on Gap 2 (compilation)
</output>
