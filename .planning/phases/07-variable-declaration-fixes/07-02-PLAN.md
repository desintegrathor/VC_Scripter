---
phase: 07-variable-declaration-fixes
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - vcdecomp/core/ir/structure/analysis/variables.py
  - vcdecomp/core/ir/structure/orchestrator.py
  - vcdecomp/tests/test_validation.py
autonomous: true

must_haves:
  truths:
    - "Variable declarations use refined types from type inference (not generic 'dword')"
    - "Struct types inferred from function call patterns (SC_P_GetInfo(&local_5) → s_SC_P_getinfo)"
    - "Array declarations generated with correct dimensions from usage patterns"
  artifacts:
    - path: "vcdecomp/core/ir/structure/analysis/variables.py"
      provides: "Declaration generation with type_inference integration"
      contains: "type_inference\\.integrate_with_ssa_values"
    - path: "vcdecomp/core/ir/structure/orchestrator.py"
      provides: "Type inference invocation before variable collection"
      contains: "type_inference\\.integrate_with_ssa_values"
  key_links:
    - from: "orchestrator.py"
      to: "type_inference.integrate_with_ssa_values()"
      via: "Call before _collect_local_variables"
      pattern: "integrate_with_ssa_values\\(ssa_func\\)"
    - from: "variables.py"
      to: "SSAValue.value_type"
      via: "Read refined types from SSA"
      pattern: "value\\.value_type"
---

<objective>
Integrate refined type inference results into variable declaration generation.

Purpose: Plan 07-01 establishes type integration in stack_lifter and type_inference. This plan ensures those refined types flow into variable declarations, replacing generic `dword` with accurate C types (int, float, struct types).

Output: Variable declarations generated from refined SSA types, eliminating Pattern 2 type mismatches in declarations.
</objective>

<execution_context>
@C:\Users\flori\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\flori\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\Users\flori\source\repos\VC_Scripter\.planning\PROJECT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\ROADMAP.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\STATE.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-CONTEXT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-RESEARCH.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-01-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\structure\analysis\variables.py
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\structure\orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Invoke type inference integration in orchestrator</name>
  <files>vcdecomp/core/ir/structure/orchestrator.py</files>
  <action>
Modify orchestrator.py to invoke type inference before variable collection:

1. Import TypeInferenceEngine at top of file
2. In format_function_structured() or similar entry point, add sequence:
   ```python
   # After SSA construction, before variable collection
   type_engine = TypeInferenceEngine(ssa_func, formatter._header_db)
   type_engine.integrate_with_ssa_values(ssa_func)  # Refine SSA value types
   logger.info(f"Type inference completed for {func_name}")
   ```
3. Place call BEFORE _collect_local_variables() is invoked
4. Ensure HeaderDatabase is available (already exists in formatter)
5. Add error handling: log warning if type inference fails, continue with SSA initial types

Why this approach: Orchestrator is the central coordination point. Type inference must run before declaration generation but after SSA construction. This is the integration point identified in RESEARCH.md.

What to avoid: Don't run type inference multiple times (expensive). Don't skip on error - degraded output is better than crash.
  </action>
  <verify>
python -m pytest vcdecomp/tests/test_validation.py::test_decompilation_validation -v --log-cli-level=INFO 2>&1 | grep "Type inference completed"

Log shows type inference invoked for each function before variable collection.

CRITICAL WIRING CHECK: Verify SSA values have refined types BEFORE variables.py reads them:
python -c "
import logging
logging.basicConfig(level=logging.DEBUG)
from vcdecomp.tests.test_validation import test_decompilation_validation
test_decompilation_validation()
" 2>&1 | grep -A 2 "Type inference refined"

Should show SSA value.value_type updates logged, confirming write-back to SSA values.
  </verify>
  <done>
Orchestrator invokes type_inference.integrate_with_ssa_values() after SSA construction and before variable collection. Log confirms execution for each function. SSA values confirmed updated with refined types (value_type field written back).
  </done>
</task>

<task type="auto">
  <name>Task 2: Update variable declaration generation to use refined types</name>
  <files>vcdecomp/core/ir/structure/analysis/variables.py</files>
  <action>
Modify variables.py _collect_local_variables() to use refined SSA types:

1. Update process_value() type resolution priority:
   ```python
   # NEW Priority order (top to bottom):
   # 1. Inferred struct types from function calls (existing - lines 75-78)
   # 2. SSA value refined type (NEW - from type_inference.integrate_with_ssa_values)
   # 3. Struct ranges from field tracker (existing - lines 80-85)
   # 4. Default fallback (existing - line 92)
   ```
2. Add helper function result_type_to_c_type(result_type: ResultType) → str in variables.py:
   ```python
   from ..disasm.opcodes import ResultType

   def result_type_to_c_type(result_type: ResultType) -> str:
       """Map ResultType enum values from opcodes.py to C type strings."""
       mapping = {
           ResultType.FLOAT: "float",
           ResultType.INT: "int",
           ResultType.DOUBLE: "double",
           ResultType.CHAR: "char",
           ResultType.SHORT: "short",
           ResultType.LONG: "long",
           ResultType.UNKNOWN: None  # Fallback to default_type
       }
       c_type = mapping.get(result_type)
       if c_type is None:
           logger.warning(f"Unmapped ResultType: {result_type}, using fallback")
           return None
       return c_type
   ```
3. Insert check after line 78 (struct types):
   ```python
   elif value.value_type != opcodes.ResultType.UNKNOWN:
       var_type = result_type_to_c_type(value.value_type)
       if var_type is None:  # Unmapped type
           var_type = default_type
   ```
4. Preserve existing struct inference logic (lines 112-163) - struct types override opcode types

Why this approach: Minimal change to existing priority system. SSA refined types slot in between high-confidence struct inference and low-confidence defaults. Preserves all Phase 6 fixes. Complete mapping with logging for unmapped types ensures robustness.

What to avoid: Don't replace existing struct inference - it's more specific than opcode types. Don't break array detection (lines 165-253) - arrays use size analysis, not just types.
  </action>
  <verify>
python -m pytest vcdecomp/tests/test_validation.py::test_decompilation_validation -v

Decompiled output shows variable declarations with specific types (float, int) instead of generic "dword" or "int" for all variables.

Inspect .test_artifacts_07-02/test1_declarations.c for:
- Float variables declared as "float" (not "int" or "dword")
- Int variables declared as "int"
- Struct types preserved from function call inference
  </verify>
  <done>
Variable declarations generated from SSA refined types. Manual inspection shows float/int/struct declarations matching actual usage patterns from ERROR_BASELINE.md Pattern 2 examples. Helper function result_type_to_c_type maps all ResultType enum values from opcodes.py with logging for unmapped types.
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate Pattern 2 elimination and create comparison report</name>
  <files>vcdecomp/tests/test_validation.py</files>
  <action>
Validate that Pattern 2 type mismatches are eliminated with declaration fixes:

1. Run full decompilation on test1/test2/test3
2. Capture decompiled output to .test_artifacts_07-02/
3. Manual inspection for Pattern 2 instances from ERROR_BASELINE.md:

   Test1 examples to check:
   - Line 65-67: tmp5 = SC_ggf(400); tmp5 = 30.0f; return tmp5;
     * Before: tmp5 declared as s_SC_MP_EnumPlayers (WRONG)
     * After: tmp5 declared as float (CORRECT)
   - Line 88-90: tmp6 = tmp5; tmp6 = 5.0f; tmp6 = 10.0f;
     * Before: tmp6 declared as s_SC_MP_EnumPlayers (WRONG)
     * After: tmp6 declared as float (CORRECT)

   Test3 examples to check:
   - Line 84: *tmp = -20000.0f;
     * Before: tmp declared as int (WRONG)
     * After: tmp declared as float* or proper pointer type (CORRECT)

4. Create comparison report: .test_artifacts_07-02/PATTERN2_ELIMINATION.md
   - List each ERROR_BASELINE.md Pattern 2 instance
   - Show before/after declarations
   - Calculate elimination rate: (fixed/total) * 100%

5. Attempt compilation with SCMP.exe:
   - If compiles: SUCCESS - capture .err files (should be empty or minimal)
   - If crashes: Document remaining issues for next plan
   - Compare error count vs Phase 6 baseline

Why this approach: Pattern 2 is the critical success criterion from Phase 6 deferral. Systematic comparison against ERROR_BASELINE.md examples proves the fix works. Compilation attempt validates end-to-end.

What to avoid: Don't expect 100% compilation success - other patterns may remain. Focus on type mismatch elimination in declarations.

NOTE: This task involves extensive manual validation work. If context budget becomes strained, consider splitting into 07-02a (integration code only) and 07-02b (Pattern 2 validation) in future revision.
  </action>
  <verify>
cat C:/Users/flori/source/repos/VC_Scripter/.test_artifacts_07-02/PATTERN2_ELIMINATION.md

Report exists with:
- Before/after declaration comparisons for each ERROR_BASELINE.md Pattern 2 instance
- Elimination rate calculation
- Compilation attempt results
  </verify>
  <done>
Pattern 2 elimination validated against ERROR_BASELINE.md examples. Report shows elimination rate and compilation status. Type mismatch errors in variable declarations reduced to near-zero.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:

1. Orchestrator calls type inference before variable collection
2. Variable declarations use SSA refined types (not generic defaults)
3. Pattern 2 instances from ERROR_BASELINE.md eliminated in declarations
4. Compilation attempt shows improvement vs Phase 6 baseline
5. No regression in Phase 6 fixes (Pattern 1, 3, 5 still working)
</verification>

<success_criteria>
Measurable completion:

1. Type inference invoked in orchestrator for every function (log confirms)
2. Variable declarations show float/int/struct types matching usage (manual inspection)
3. Pattern 2 type mismatch instances reduced >80% vs ERROR_BASELINE.md
4. PATTERN2_ELIMINATION.md report created with systematic comparison
5. Compilation attempt produces error files (not crashes) or succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/07-variable-declaration-fixes/07-02-SUMMARY.md`
</output>
