---
phase: 07-variable-declaration-fixes
plan: 10
type: execute
wave: 10
depends_on: [07-09]
files_modified:
  - vcdecomp/core/ir/structure/orchestrator.py
  - vcdecomp/core/ir/cfg.py
autonomous: true
gap_closure: true
requires_git_bash: true

must_haves:
  truths:
    - "Decompiled code contains NO debug logging pollution in output"
    - "ScriptMain function successfully reconstructed with valid entry block"
    - "Code is parseable by SCMP.exe (no pre-compilation crashes)"
  artifacts:
    - path: "vcdecomp/core/ir/structure/orchestrator.py"
      provides: "Removed logger.warning() from code emission path"
      min_lines: 800
      exports: ["structured_decompile"]
    - path: "vcdecomp/core/ir/cfg.py"
      provides: "ScriptMain entry block detection fixed"
      min_lines: 200
      exports: ["build_cfg"]
    - path: ".test_artifacts_07-10/test1_clean.c"
      provides: "Test1 output with no debug pollution"
      contains: "^// Structured decompilation"
    - path: ".test_artifacts_07-10/test1_scriptmain_check.txt"
      provides: "ScriptMain validation report"
      contains: "ScriptMain.*FOUND"
  key_links:
    - from: "orchestrator.py logger.warning()"
      to: "stdout/stderr pollution"
      via: "Removed warning calls from emission functions"
      pattern: "# logger\\.warning.*orphaned"
    - from: "cfg.py _resolve_entry_ip()"
      to: "ScriptMain entry block"
      via: "Entry point resolution already handles negative offsets"
      pattern: "enter_ip.*-2"
---

<objective>
Eliminate critical compilation blockers: debug logging pollution (Category 1) and broken ScriptMain function (Category 2).

Purpose: Gap 2 from 07-VERIFICATION.md shows test1_final.c lines 1-63 contain debug messages that prevent SCMP.exe from parsing the file. Line 123 shows ScriptMain entry block detection failed. These are both CRITICAL blockers that must be resolved before any compilation attempt.

Output: Clean decompiled output with no debug pollution and functional ScriptMain entry point.
</objective>

<execution_context>
@C:\Users\flori\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\flori\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\Users\flori\source\repos\VC_Scripter\.planning\PROJECT.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\ROADMAP.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\STATE.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-VERIFICATION.md
@C:\Users\flori\source\repos\VC_Scripter\.planning\phases\07-variable-declaration-fixes\07-09-SUMMARY.md
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\structure\orchestrator.py
@C:\Users\flori\source\repos\VC_Scripter\vcdecomp\core\ir\cfg.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove Debug Logging Pollution</name>
  <files>vcdecomp/core/ir/structure/orchestrator.py</files>
  <action>
Remove logger.warning() calls that pollute stdout/stderr in code emission path.

**Problem locations (from 07-09-SUMMARY.md):**
- orchestrator.py line 381: Orphaned block warnings
- block_formatter.py: [POST-PROCESS] messages

**Evidence from test1_final.c lines 1-63:**
```
[POST-PROCESS] Starting Pattern 2 cleanup on 0 declarations
Skipping orphaned block 2 at address 53 in function func_0050 - no predecessors (unreachable code)
```

**Root cause:** logger.warning() outputs to stderr, which gets captured in test artifact files and pollutes decompiled code output.

**Fix strategy:**

1. **Search for all logger.warning() in orchestrator.py:**
```bash
grep -n "logger.warning" vcdecomp/core/ir/structure/orchestrator.py
```

2. **Replace logger.warning() with logger.debug():**
- Debug level messages only appear when --log-level=DEBUG explicitly set
- Production decompilation (structure command) runs at INFO level by default
- Diagnostic messages become opt-in instead of polluting output

3. **Specific changes:**

**Line ~381 (orphaned block warnings):**
```python
# BEFORE:
logger.warning(f"Skipping orphaned block {block_id} at address {block.start_addr} "
               f"in function {func_name} - no predecessors (unreachable code)")

# AFTER:
logger.debug(f"Skipping orphaned block {block_id} at address {block.start_addr} "
             f"in function {func_name} - no predecessors (unreachable code)")
```

**Pattern 2 cleanup messages (search for POST-PROCESS):**
If found in orchestrator.py, change to logger.debug()

4. **Verify no production warnings remain:**
```bash
# Should find 0 logger.warning in code emission path
grep -n "logger.warning" vcdecomp/core/ir/structure/orchestrator.py | grep -v "# logger.warning"
```

**Why this works:**
- Debug messages still available for diagnostics with --log-level=DEBUG flag
- Production output clean by default
- No loss of debugging capability for future development
  </action>
  <verify>
NOTE: Requires Git Bash (bash.exe) available in PATH.

```bash
cd "C:\Users\flori\source\repos\VC_Scripter"
mkdir -p .test_artifacts_07-10

# Decompile test1 with cleaned-up logging
python -m vcdecomp structure "C:\Users\flori\source\repos\VC_Scripter\decompiler_source_tests\test1\tt.scr" > .test_artifacts_07-10/test1_clean.c 2>&1

# Check first 70 lines - should have NO debug messages
head -70 .test_artifacts_07-10/test1_clean.c > .test_artifacts_07-10/first_70_lines.txt

# Verify clean output
grep -E "\[POST-PROCESS\]|Skipping orphaned" .test_artifacts_07-10/test1_clean.c || echo "SUCCESS: No debug pollution found"

# Expected: "SUCCESS: No debug pollution found"
# If pollution remains, check which source file is still using logger.warning()
```
  </verify>
  <done>
- orchestrator.py has NO logger.warning() calls in code emission path (grep confirms)
- test1_clean.c first 70 lines contain NO debug messages
- Output starts with "// Structured decompilation" comment (actual C code, not logs)
- Debug diagnostics still available via --log-level=DEBUG flag
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix ScriptMain Entry Block Detection</name>
  <files>vcdecomp/core/ir/cfg.py</files>
  <action>
Fix ScriptMain function reconstruction to correctly identify entry block from header metadata.

**Problem:** test1_final.c line 123 shows:
```c
// Function ScriptMain at -1098 - entry block not found
```

**Root cause:** Verified from cfg.py source code - _resolve_entry_ip() already handles negative offsets correctly (lines 40-88), but orchestrator may be looking for entry block using wrong logic.

**Investigation findings:**

1. **cfg.py already handles special entry points correctly:**
   - Line 51-59: enter_ip == -2 → ScriptMain at address 0
   - Line 61-88: enter_ip < -2 → detect ScriptMain after last helper RET
   - Line 158: entry_block = start_to_block.get(entry_ip, 0) with fallback to block 0

2. **Actual problem location:**
   - cfg.py build_cfg() correctly resolves entry_ip and sets entry_block
   - orchestrator.py likely has function detection that doesn't use cfg.entry_block
   - Search orchestrator.py for "ScriptMain" and "entry block not found" error message

**Fix strategy:**

1. **Locate error message source:**
```bash
# Find where "entry block not found" error is generated
grep -n "entry block not found" vcdecomp/core/ir/structure/orchestrator.py
```

2. **Expected issue:**
   - orchestrator.py function detection may be constructing function entries manually
   - Instead of using cfg.entry_block from build_cfg(), it may be trying to find entry by offset
   - This would fail for ScriptMain with negative enter_ip

3. **Fix (in orchestrator.py):**
```python
# BEFORE: Trying to find entry block manually
entry_block = None
for block in blocks:
    if block.start == entry_offset:
        entry_block = block
        break

# AFTER: Use cfg.entry_block from build_cfg()
entry_block = cfg.entry_block  # Already resolved by _resolve_entry_ip()
```

4. **Alternative: Add ScriptMain special case:**
```python
# If ScriptMain detection is separate from normal CFG construction
if func_name == "ScriptMain":
    # Use cfg.entry_block which was correctly resolved
    entry_block = cfg.entry_block
else:
    # Normal function entry detection
    ...
```

**Why this works:**
- cfg.py _resolve_entry_ip() already implements correct logic for negative offsets
- orchestrator just needs to use cfg.entry_block instead of reimplementing detection
- ScriptMain will use resolved entry_ip (either 0 or address after last helper RET)
  </action>
  <verify>
NOTE: Requires Git Bash (bash.exe) available in PATH.

```bash
cd "C:\Users\flori\source\repos\VC_Scripter"

# Decompile with ScriptMain fix
python -m vcdecomp structure "C:\Users\flori\source\repos\VC_Scripter\decompiler_source_tests\test1\tt.scr" > .test_artifacts_07-10/test1_scriptmain.c 2>&1

# Check ScriptMain function status
grep -A 10 "ScriptMain" .test_artifacts_07-10/test1_scriptmain.c > .test_artifacts_07-10/test1_scriptmain_check.txt

# Verify ScriptMain function exists with body
if grep -q "void ScriptMain()" .test_artifacts_07-10/test1_scriptmain_check.txt && \
   grep -q "{" .test_artifacts_07-10/test1_scriptmain_check.txt; then
    echo "ScriptMain FOUND with function body" >> .test_artifacts_07-10/test1_scriptmain_check.txt
else
    echo "ScriptMain MISSING or malformed" >> .test_artifacts_07-10/test1_scriptmain_check.txt
fi

cat .test_artifacts_07-10/test1_scriptmain_check.txt
```
  </verify>
  <done>
- ScriptMain function appears in test1_scriptmain.c with valid function body
- NO "entry block not found" error message in output
- test1_scriptmain_check.txt shows "ScriptMain FOUND with function body"
- orchestrator uses cfg.entry_block instead of manual entry point detection
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate Clean Output</name>
  <files>.test_artifacts_07-10/validation_report.txt</files>
  <action>
Comprehensive validation that both blockers eliminated across all 3 test files.

**Validation checklist:**

1. **Category 1 validation (debug pollution):**
```bash
cd "C:\Users\flori\source\repos\VC_Scripter"

echo "=== Category 1: Debug Logging Pollution ===" > .test_artifacts_07-10/validation_report.txt
echo "" >> .test_artifacts_07-10/validation_report.txt

# Decompile all 3 tests
python -m vcdecomp structure "decompiler_source_tests/test1/tt.scr" > .test_artifacts_07-10/test1_final.c 2>&1
python -m vcdecomp structure "decompiler_source_tests/test2/tdm.scr" > .test_artifacts_07-10/test2_final.c 2>&1
python -m vcdecomp structure "decompiler_source_tests/test3/LEVEL.SCR" > .test_artifacts_07-10/test3_final.c 2>&1

# Check for debug pollution in first 100 lines of each
echo "Test1 debug pollution check:" >> .test_artifacts_07-10/validation_report.txt
head -100 .test_artifacts_07-10/test1_final.c | grep -E "\[POST-PROCESS\]|Skipping orphaned" >> .test_artifacts_07-10/validation_report.txt || echo "  CLEAN - no debug messages" >> .test_artifacts_07-10/validation_report.txt

echo "" >> .test_artifacts_07-10/validation_report.txt
echo "Test2 debug pollution check:" >> .test_artifacts_07-10/validation_report.txt
head -100 .test_artifacts_07-10/test2_final.c | grep -E "\[POST-PROCESS\]|Skipping orphaned" >> .test_artifacts_07-10/validation_report.txt || echo "  CLEAN - no debug messages" >> .test_artifacts_07-10/validation_report.txt

echo "" >> .test_artifacts_07-10/validation_report.txt
echo "Test3 debug pollution check:" >> .test_artifacts_07-10/validation_report.txt
head -100 .test_artifacts_07-10/test3_final.c | grep -E "\[POST-PROCESS\]|Skipping orphaned" >> .test_artifacts_07-10/validation_report.txt || echo "  CLEAN - no debug messages" >> .test_artifacts_07-10/validation_report.txt
```

2. **Category 2 validation (ScriptMain):**
```bash
echo "" >> .test_artifacts_07-10/validation_report.txt
echo "=== Category 2: ScriptMain Function ===" >> .test_artifacts_07-10/validation_report.txt
echo "" >> .test_artifacts_07-10/validation_report.txt

# Check each test for ScriptMain
for test in test1 test2 test3; do
    echo "${test} ScriptMain check:" >> .test_artifacts_07-10/validation_report.txt
    if grep -q "void ScriptMain()" .test_artifacts_07-10/${test}_final.c; then
        echo "  FOUND - function exists" >> .test_artifacts_07-10/validation_report.txt
    elif grep -q "entry block not found" .test_artifacts_07-10/${test}_final.c; then
        echo "  BROKEN - entry block not found" >> .test_artifacts_07-10/validation_report.txt
    else
        echo "  N/A - no ScriptMain in this test" >> .test_artifacts_07-10/validation_report.txt
    fi
done
```

3. **Summary:**
```bash
echo "" >> .test_artifacts_07-10/validation_report.txt
echo "=== SUMMARY ===" >> .test_artifacts_07-10/validation_report.txt
echo "Category 1 (debug pollution): EXPECTED 0 instances across all tests" >> .test_artifacts_07-10/validation_report.txt
echo "Category 2 (ScriptMain): EXPECTED 'FOUND' or 'N/A' (not 'BROKEN')" >> .test_artifacts_07-10/validation_report.txt
echo "" >> .test_artifacts_07-10/validation_report.txt
echo "Status: Critical blockers eliminated, ready for compilation attempt in 07-11" >> .test_artifacts_07-10/validation_report.txt

cat .test_artifacts_07-10/validation_report.txt
```
  </action>
  <verify>
NOTE: Requires Git Bash (bash.exe) available in PATH.

```bash
# Verify validation report contents
cat .test_artifacts_07-10/validation_report.txt

# Check for critical failures
if grep -q "BROKEN" .test_artifacts_07-10/validation_report.txt; then
    echo "FAILED: ScriptMain still broken"
    exit 1
fi

if grep -q "\[POST-PROCESS\]" .test_artifacts_07-10/test1_final.c; then
    echo "FAILED: Debug pollution remains"
    exit 1
fi

echo "SUCCESS: Both critical blockers eliminated"
```
  </verify>
  <done>
- validation_report.txt shows 0 debug pollution instances across all tests
- All ScriptMain functions show "FOUND" or "N/A" status (not "BROKEN")
- test1_final.c, test2_final.c, test3_final.c are parseable C code
- Output files start with proper C comments and includes (not debug logs)
  </done>
</task>

</tasks>

<verification>
## Critical Blocker Elimination Verification

**Success Criteria:**
1. All decompiled output files start with valid C code (no debug messages)
2. ScriptMain function successfully reconstructed where present
3. SCMP.exe can parse the files (compilation may still fail on semantic errors, but no pre-parsing crashes)

**Verification Commands:**
```bash
# Category 1: Debug pollution check
head -100 .test_artifacts_07-10/test1_final.c | grep -E "\[POST|Skipping"
# Expected: No matches (empty output)

# Category 2: ScriptMain check
grep "ScriptMain" .test_artifacts_07-10/test1_final.c
# Expected: "void ScriptMain()" with function body, NOT "entry block not found"

# Parseable C code check
head -10 .test_artifacts_07-10/test1_final.c
# Expected: Starts with "// Structured decompilation" comment and includes
```

**Manual Inspection:**
1. Open .test_artifacts_07-10/test1_final.c
2. Verify first line is C comment, not debug message
3. Search for ScriptMain - should have function body, not error comment
4. Compare to .test_artifacts_07-08/test1_final.c (before fix) to confirm improvement

</verification>

<success_criteria>
## Gap 2 Critical Blockers Eliminated (Categories 1 & 2)

**Measurable Outcomes:**
1. Debug pollution eliminated: 0 instances in all test files (previously 63 lines in test1)
2. ScriptMain reconstructed: "void ScriptMain() { ... }" appears in output
3. Code is parseable: No pre-compilation crashes when SCMP.exe attempts to read file

**Acceptance Test:**
```bash
# Test all 3 files for clean output
for test in test1 test2 test3; do
    python -m vcdecomp structure "decompiler_source_tests/${test}/*.scr" 2>&1 | \
    head -100 | \
    grep -E "\[POST-PROCESS\]|Skipping orphaned|entry block not found" && \
    echo "${test}: FAILED" || echo "${test}: CLEAN"
done

# Expected: All tests show "CLEAN"
```

**Next Steps:**
- Plan 07-11: Category 3 (void return elimination)
- Plan 07-12: Categories 4 & 5 (uninitialized vars, unreachable code)
- Plan 07-13: Compilation validation attempt
</success_criteria>

<output>
After completion, create `.planning/phases/07-variable-declaration-fixes/07-10-SUMMARY.md` with:
- Evidence of debug pollution elimination (before/after comparison)
- ScriptMain function reconstruction validation
- Validation report showing 0 critical blockers across all 3 tests
- Impact assessment: Files now parseable by SCMP.exe (ready for compilation attempt)
</output>
